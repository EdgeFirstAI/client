// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(EdgeFirstClientFFI)
  import EdgeFirstClientFFI
#endif

extension RustBuffer {
  // Allocate a new buffer, copying the contents of a `UInt8` array.
  fileprivate init(bytes: [UInt8]) {
    let rbuf = bytes.withUnsafeBufferPointer { ptr in
      RustBuffer.from(ptr)
    }
    self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
  }

  fileprivate static func empty() -> RustBuffer {
    RustBuffer(capacity: 0, len: 0, data: nil)
  }

  fileprivate static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
    try! rustCall {
      ffi_edgefirst_client_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0)
    }
  }

  // Frees the buffer in place.
  // The buffer must not be used after this is called.
  fileprivate func deallocate() {
    try! rustCall { ffi_edgefirst_client_rustbuffer_free(self, $0) }
  }
}

extension ForeignBytes {
  fileprivate init(bufferPointer: UnsafeBufferPointer<UInt8>) {
    self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
  }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

extension Data {
  fileprivate init(rustBuffer: RustBuffer) {
    self.init(
      bytesNoCopy: rustBuffer.data!,
      count: Int(rustBuffer.len),
      deallocator: .none
    )
  }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
  (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws
  -> T
{
  let range = reader.offset..<reader.offset + MemoryLayout<T>.size
  guard reader.data.count >= range.upperBound else {
    throw UniffiInternalError.bufferOverflow
  }
  if T.self == UInt8.self {
    let value = reader.data[reader.offset]
    reader.offset += 1
    return value as! T
  }
  var value: T = 0
  let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range) })
  reader.offset = range.upperBound
  return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws
  -> [UInt8]
{
  let range = reader.offset..<(reader.offset + count)
  guard reader.data.count >= range.upperBound else {
    throw UniffiInternalError.bufferOverflow
  }
  var value = [UInt8](repeating: 0, count: count)
  value.withUnsafeMutableBufferPointer({ buffer in
    reader.data.copyBytes(to: buffer, from: range)
  })
  reader.offset = range.upperBound
  return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
  return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
  return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
  return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
  return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S)
where S: Sequence, S.Element == UInt8 {
  writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
  var value = value.bigEndian
  withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
  writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
  writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
private protocol FfiConverter {
  associatedtype FfiType
  associatedtype SwiftType

  static func lift(_ value: FfiType) throws -> SwiftType
  static func lower(_ value: SwiftType) -> FfiType
  static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
  static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
  #if swift(>=5.8)
    @_documentation(visibility: private)
  #endif
  public static func lift(_ value: FfiType) throws -> SwiftType {
    return value
  }

  #if swift(>=5.8)
    @_documentation(visibility: private)
  #endif
  public static func lower(_ value: SwiftType) -> FfiType {
    return value
  }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
  #if swift(>=5.8)
    @_documentation(visibility: private)
  #endif
  public static func lift(_ buf: RustBuffer) throws -> SwiftType {
    var reader = createReader(data: Data(rustBuffer: buf))
    let value = try read(from: &reader)
    if hasRemaining(reader) {
      throw UniffiInternalError.incompleteData
    }
    buf.deallocate()
    return value
  }

  #if swift(>=5.8)
    @_documentation(visibility: private)
  #endif
  public static func lower(_ value: SwiftType) -> RustBuffer {
    var writer = createWriter()
    write(value, into: &writer)
    return RustBuffer(bytes: writer)
  }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
  case bufferOverflow
  case incompleteData
  case unexpectedOptionalTag
  case unexpectedEnumCase
  case unexpectedNullPointer
  case unexpectedRustCallStatusCode
  case unexpectedRustCallError
  case unexpectedStaleHandle
  case rustPanic(_ message: String)

  public var errorDescription: String? {
    switch self {
    case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
    case .incompleteData: return "The buffer still has data after lifting its containing value"
    case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
    case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
    case .unexpectedNullPointer: return "Raw pointer value was null"
    case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
    case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
    case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
    case .rustPanic(let message): return message
    }
  }
}

extension NSLock {
  fileprivate func withLock<T>(f: () throws -> T) rethrows -> T {
    self.lock()
    defer { self.unlock() }
    return try f()
  }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

extension RustCallStatus {
  fileprivate init() {
    self.init(
      code: CALL_SUCCESS,
      errorBuf: RustBuffer.init(
        capacity: 0,
        len: 0,
        data: nil
      )
    )
  }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
  let neverThrow: ((RustBuffer) throws -> Never)? = nil
  return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
  _ errorHandler: @escaping (RustBuffer) throws -> E,
  _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
  try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
  _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
  errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
  uniffiEnsureEdgefirstClientInitialized()
  var callStatus = RustCallStatus.init()
  let returnedVal = callback(&callStatus)
  try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
  return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
  callStatus: RustCallStatus,
  errorHandler: ((RustBuffer) throws -> E)?
) throws {
  switch callStatus.code {
  case CALL_SUCCESS:
    return

  case CALL_ERROR:
    if let errorHandler = errorHandler {
      throw try errorHandler(callStatus.errorBuf)
    } else {
      callStatus.errorBuf.deallocate()
      throw UniffiInternalError.unexpectedRustCallError
    }

  case CALL_UNEXPECTED_ERROR:
    // When the rust code sees a panic, it tries to construct a RustBuffer
    // with the message.  But if that code panics, then it just sends back
    // an empty buffer.
    if callStatus.errorBuf.len > 0 {
      throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
    } else {
      callStatus.errorBuf.deallocate()
      throw UniffiInternalError.rustPanic("Rust panic")
    }

  case CALL_CANCELLED:
    fatalError("Cancellation not supported yet")

  default:
    throw UniffiInternalError.unexpectedRustCallStatusCode
  }
}

private func uniffiTraitInterfaceCall<T>(
  callStatus: UnsafeMutablePointer<RustCallStatus>,
  makeCall: () throws -> T,
  writeReturn: (T) -> Void
) {
  do {
    try writeReturn(makeCall())
  } catch let error {
    callStatus.pointee.code = CALL_UNEXPECTED_ERROR
    callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
  }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
  callStatus: UnsafeMutablePointer<RustCallStatus>,
  makeCall: () throws -> T,
  writeReturn: (T) -> Void,
  lowerError: (E) -> RustBuffer
) {
  do {
    try writeReturn(makeCall())
  } catch let error as E {
    callStatus.pointee.code = CALL_ERROR
    callStatus.pointee.errorBuf = lowerError(error)
  } catch {
    callStatus.pointee.code = CALL_UNEXPECTED_ERROR
    callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
  }
}
// Initial value and increment amount for handles.
// These ensure that SWIFT handles always have the lowest bit set
private let UNIFFI_HANDLEMAP_INITIAL: UInt64 = 1
private let UNIFFI_HANDLEMAP_DELTA: UInt64 = 2

private final class UniffiHandleMap<T>: @unchecked Sendable {
  // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
  private let lock = NSLock()
  private var map: [UInt64: T] = [:]
  private var currentHandle: UInt64 = UNIFFI_HANDLEMAP_INITIAL

  func insert(obj: T) -> UInt64 {
    lock.withLock {
      return doInsert(obj)
    }
  }

  // Low-level insert function, this assumes `lock` is held.
  private func doInsert(_ obj: T) -> UInt64 {
    let handle = currentHandle
    currentHandle += UNIFFI_HANDLEMAP_DELTA
    map[handle] = obj
    return handle
  }

  func get(handle: UInt64) throws -> T {
    try lock.withLock {
      guard let obj = map[handle] else {
        throw UniffiInternalError.unexpectedStaleHandle
      }
      return obj
    }
  }

  func clone(handle: UInt64) throws -> UInt64 {
    try lock.withLock {
      guard let obj = map[handle] else {
        throw UniffiInternalError.unexpectedStaleHandle
      }
      return doInsert(obj)
    }
  }

  @discardableResult
  func remove(handle: UInt64) throws -> T {
    try lock.withLock {
      guard let obj = map.removeValue(forKey: handle) else {
        throw UniffiInternalError.unexpectedStaleHandle
      }
      return obj
    }
  }

  var count: Int {
    map.count
  }
}

// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterUInt8: FfiConverterPrimitive {
  typealias FfiType = UInt8
  typealias SwiftType = UInt8

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
    return try lift(readInt(&buf))
  }

  public static func write(_ value: UInt8, into buf: inout [UInt8]) {
    writeInt(&buf, lower(value))
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterUInt32: FfiConverterPrimitive {
  typealias FfiType = UInt32
  typealias SwiftType = UInt32

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
    return try lift(readInt(&buf))
  }

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    writeInt(&buf, lower(value))
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterUInt64: FfiConverterPrimitive {
  typealias FfiType = UInt64
  typealias SwiftType = UInt64

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
    return try lift(readInt(&buf))
  }

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    writeInt(&buf, lower(value))
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterInt64: FfiConverterPrimitive {
  typealias FfiType = Int64
  typealias SwiftType = Int64

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
    return try lift(readInt(&buf))
  }

  public static func write(_ value: Int64, into buf: inout [UInt8]) {
    writeInt(&buf, lower(value))
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterFloat: FfiConverterPrimitive {
  typealias FfiType = Float
  typealias SwiftType = Float

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try lift(readFloat(&buf))
  }

  public static func write(_ value: Float, into buf: inout [UInt8]) {
    writeFloat(&buf, lower(value))
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterDouble: FfiConverterPrimitive {
  typealias FfiType = Double
  typealias SwiftType = Double

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try lift(readDouble(&buf))
  }

  public static func write(_ value: Double, into buf: inout [UInt8]) {
    writeDouble(&buf, lower(value))
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterBool: FfiConverter {
  typealias FfiType = Int8
  typealias SwiftType = Bool

  public static func lift(_ value: Int8) throws -> Bool {
    return value != 0
  }

  public static func lower(_ value: Bool) -> Int8 {
    return value ? 1 : 0
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
    return try lift(readInt(&buf))
  }

  public static func write(_ value: Bool, into buf: inout [UInt8]) {
    writeInt(&buf, lower(value))
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterString: FfiConverter {
  typealias SwiftType = String
  typealias FfiType = RustBuffer

  public static func lift(_ value: RustBuffer) throws -> String {
    defer {
      value.deallocate()
    }
    if value.data == nil {
      return String()
    }
    let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
    return String(bytes: bytes, encoding: String.Encoding.utf8)!
  }

  public static func lower(_ value: String) -> RustBuffer {
    return value.utf8CString.withUnsafeBufferPointer { ptr in
      // The swift string gives us int8_t, we want uint8_t.
      ptr.withMemoryRebound(to: UInt8.self) { ptr in
        // The swift string gives us a trailing null byte, we don't want it.
        let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
        return RustBuffer.from(buf)
      }
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
    let len: Int32 = try readInt(&buf)
    return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
  }

  public static func write(_ value: String, into buf: inout [UInt8]) {
    let len = Int32(value.utf8.count)
    writeInt(&buf, len)
    writeBytes(&buf, value.utf8)
  }
}

/// Main client for interacting with EdgeFirst Studio.
public protocol ClientProtocol: AnyObject, Sendable {

  /**
   * Get annotation sets for a dataset.
   */
  func annotationSets(datasetId: DatasetId) throws -> [AnnotationSet]

  /**
   * Get annotation sets for a dataset (async).
   */
  func annotationSetsAsync(datasetId: DatasetId) async throws -> [AnnotationSet]

  /**
   * Get artifacts for a training session.
   */
  func artifacts(trainingSessionId: TrainingSessionId) throws -> [Artifact]

  /**
   * Get artifacts for a training session (async).
   */
  func artifactsAsync(trainingSessionId: TrainingSessionId) async throws -> [Artifact]

  /**
   * Get a dataset by ID.
   */
  func dataset(id: DatasetId) throws -> Dataset

  /**
   * Get a dataset by ID (async).
   */
  func datasetAsync(id: DatasetId) async throws -> Dataset

  /**
   * List datasets in a project, optionally filtered by name.
   */
  func datasets(projectId: ProjectId, name: String?) throws -> [Dataset]

  /**
   * List datasets in a project (async).
   */
  func datasetsAsync(projectId: ProjectId, name: String?) async throws -> [Dataset]

  /**
   * Get an experiment by ID.
   */
  func experiment(id: ExperimentId) throws -> Experiment

  /**
   * Get an experiment by ID (async).
   */
  func experimentAsync(id: ExperimentId) async throws -> Experiment

  /**
   * List experiments in a project, optionally filtered by name.
   */
  func experiments(projectId: ProjectId, name: String?) throws -> [Experiment]

  /**
   * List experiments in a project (async).
   */
  func experimentsAsync(projectId: ProjectId, name: String?) async throws -> [Experiment]

  /**
   * Get labels for a dataset.
   */
  func labels(datasetId: DatasetId) throws -> [Label]

  /**
   * Get labels for a dataset (async).
   */
  func labelsAsync(datasetId: DatasetId) async throws -> [Label]

  /**
   * Clear authentication token and log out.
   */
  func logout() throws

  /**
   * Clear authentication token and log out (async).
   */
  func logoutAsync() async throws

  /**
   * Get the current user's organization.
   */
  func organization() throws -> Organization

  /**
   * Get the current user's organization (async).
   */
  func organizationAsync() async throws -> Organization

  /**
   * Get a project by ID.
   */
  func project(id: ProjectId) throws -> Project

  /**
   * Get a project by ID (async).
   */
  func projectAsync(id: ProjectId) async throws -> Project

  /**
   * List projects, optionally filtered by name.
   */
  func projects(name: String?) throws -> [Project]

  /**
   * List projects, optionally filtered by name (async).
   */
  func projectsAsync(name: String?) async throws -> [Project]

  /**
   * Get a snapshot by ID.
   */
  func snapshot(id: SnapshotId) throws -> Snapshot

  /**
   * Get a snapshot by ID (async).
   */
  func snapshotAsync(id: SnapshotId) async throws -> Snapshot

  /**
   * List snapshots, optionally filtered by name.
   */
  func snapshots(name: String?) throws -> [Snapshot]

  /**
   * List snapshots, optionally filtered by name (async).
   */
  func snapshotsAsync(name: String?) async throws -> [Snapshot]

  /**
   * Get task information by ID.
   */
  func taskInfo(id: TaskId) throws -> TaskInfo

  /**
   * Get task information by ID (async).
   */
  func taskInfoAsync(id: TaskId) async throws -> TaskInfo

  /**
   * Get a training session by ID.
   */
  func trainingSession(id: TrainingSessionId) throws -> TrainingSession

  /**
   * Get a training session by ID (async).
   */
  func trainingSessionAsync(id: TrainingSessionId) async throws -> TrainingSession

  /**
   * List training sessions in an experiment, optionally filtered by name.
   */
  func trainingSessions(experimentId: ExperimentId, name: String?) throws -> [TrainingSession]

  /**
   * List training sessions in an experiment (async).
   */
  func trainingSessionsAsync(experimentId: ExperimentId, name: String?) async throws
    -> [TrainingSession]

  /**
   * Get the current server URL.
   */
  func url() -> String

  /**
   * List validation sessions for a project.
   */
  func validationSessions(projectId: ProjectId) throws -> [ValidationSession]

  /**
   * List validation sessions for a project (async).
   */
  func validationSessionsAsync(projectId: ProjectId) async throws -> [ValidationSession]

  /**
   * Verify that the current token is valid.
   */
  func verifyToken() throws

  /**
   * Verify that the current token is valid (async).
   */
  func verifyTokenAsync() async throws

  /**
   * Authenticate with username and password (blocking).
   */
  func withLogin(username: String, password: String) throws -> Client

  /**
   * Authenticate with username and password (async).
   *
   * Uses `async-compat` to enter Tokio context for reqwest compatibility
   * while allowing UniFFI to drive the future from Swift/Kotlin.
   */
  func withLoginAsync(username: String, password: String) async throws -> Client

  /**
   * Returns a new client connected to the specified server instance.
   *
   * Server names: "" or "saas" → production, "test", "stage", "dev", or
   * custom.
   */
  func withServer(name: String) throws -> Client

  /**
   * Returns a new client with the specified authentication token.
   */
  func withToken(token: String) throws -> Client

}
/// Main client for interacting with EdgeFirst Studio.
open class Client: ClientProtocol, @unchecked Sendable {
  fileprivate let handle: UInt64

  /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
  #if swift(>=5.8)
    @_documentation(visibility: private)
  #endif
  public struct NoHandle {
    public init() {}
  }

  // TODO: We'd like this to be `private` but for Swifty reasons,
  // we can't implement `FfiConverter` without making this `required` and we can't
  // make it `required` without making it `public`.
  #if swift(>=5.8)
    @_documentation(visibility: private)
  #endif
  required public init(unsafeFromHandle handle: UInt64) {
    self.handle = handle
  }

  // This constructor can be used to instantiate a fake object.
  // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
  //
  // - Warning:
  //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
  #if swift(>=5.8)
    @_documentation(visibility: private)
  #endif
  public init(noHandle: NoHandle) {
    self.handle = 0
  }

  #if swift(>=5.8)
    @_documentation(visibility: private)
  #endif
  public func uniffiCloneHandle() -> UInt64 {
    return try! rustCall { uniffi_edgefirst_client_fn_clone_client(self.handle, $0) }
  }
  /**
   * Create a new client with default file token storage.
   */
  public convenience init() throws {
    let handle =
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_constructor_client_new(
          $0
        )
      }
    self.init(unsafeFromHandle: handle)
  }

  deinit {
    try! rustCall { uniffi_edgefirst_client_fn_free_client(handle, $0) }
  }

  /**
   * Create a new client with in-memory token storage (no persistence).
   */
  public static func withMemoryStorage() throws -> Client {
    return try FfiConverterTypeClient_lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_constructor_client_with_memory_storage(
          $0
        )
      })
  }

  /**
   * Get annotation sets for a dataset.
   */
  open func annotationSets(datasetId: DatasetId) throws -> [AnnotationSet] {
    return try FfiConverterSequenceTypeAnnotationSet.lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_annotation_sets(
          self.uniffiCloneHandle(),
          FfiConverterTypeDatasetId_lower(datasetId), $0
        )
      })
  }

  /**
   * Get annotation sets for a dataset (async).
   */
  open func annotationSetsAsync(datasetId: DatasetId) async throws -> [AnnotationSet] {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_annotation_sets_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeDatasetId_lower(datasetId)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterSequenceTypeAnnotationSet.lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Get artifacts for a training session.
   */
  open func artifacts(trainingSessionId: TrainingSessionId) throws -> [Artifact] {
    return try FfiConverterSequenceTypeArtifact.lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_artifacts(
          self.uniffiCloneHandle(),
          FfiConverterTypeTrainingSessionId_lower(trainingSessionId), $0
        )
      })
  }

  /**
   * Get artifacts for a training session (async).
   */
  open func artifactsAsync(trainingSessionId: TrainingSessionId) async throws -> [Artifact] {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_artifacts_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeTrainingSessionId_lower(trainingSessionId)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterSequenceTypeArtifact.lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Get a dataset by ID.
   */
  open func dataset(id: DatasetId) throws -> Dataset {
    return try FfiConverterTypeDataset_lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_dataset(
          self.uniffiCloneHandle(),
          FfiConverterTypeDatasetId_lower(id), $0
        )
      })
  }

  /**
   * Get a dataset by ID (async).
   */
  open func datasetAsync(id: DatasetId) async throws -> Dataset {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_dataset_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeDatasetId_lower(id)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterTypeDataset_lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * List datasets in a project, optionally filtered by name.
   */
  open func datasets(projectId: ProjectId, name: String?) throws -> [Dataset] {
    return try FfiConverterSequenceTypeDataset.lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_datasets(
          self.uniffiCloneHandle(),
          FfiConverterTypeProjectId_lower(projectId),
          FfiConverterOptionString.lower(name), $0
        )
      })
  }

  /**
   * List datasets in a project (async).
   */
  open func datasetsAsync(projectId: ProjectId, name: String?) async throws -> [Dataset] {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_datasets_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeProjectId_lower(projectId), FfiConverterOptionString.lower(name)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterSequenceTypeDataset.lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Get an experiment by ID.
   */
  open func experiment(id: ExperimentId) throws -> Experiment {
    return try FfiConverterTypeExperiment_lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_experiment(
          self.uniffiCloneHandle(),
          FfiConverterTypeExperimentId_lower(id), $0
        )
      })
  }

  /**
   * Get an experiment by ID (async).
   */
  open func experimentAsync(id: ExperimentId) async throws -> Experiment {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_experiment_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeExperimentId_lower(id)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterTypeExperiment_lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * List experiments in a project, optionally filtered by name.
   */
  open func experiments(projectId: ProjectId, name: String?) throws -> [Experiment] {
    return try FfiConverterSequenceTypeExperiment.lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_experiments(
          self.uniffiCloneHandle(),
          FfiConverterTypeProjectId_lower(projectId),
          FfiConverterOptionString.lower(name), $0
        )
      })
  }

  /**
   * List experiments in a project (async).
   */
  open func experimentsAsync(projectId: ProjectId, name: String?) async throws -> [Experiment] {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_experiments_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeProjectId_lower(projectId), FfiConverterOptionString.lower(name)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterSequenceTypeExperiment.lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Get labels for a dataset.
   */
  open func labels(datasetId: DatasetId) throws -> [Label] {
    return try FfiConverterSequenceTypeLabel.lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_labels(
          self.uniffiCloneHandle(),
          FfiConverterTypeDatasetId_lower(datasetId), $0
        )
      })
  }

  /**
   * Get labels for a dataset (async).
   */
  open func labelsAsync(datasetId: DatasetId) async throws -> [Label] {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_labels_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeDatasetId_lower(datasetId)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterSequenceTypeLabel.lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Clear authentication token and log out.
   */
  open func logout() throws {
    try rustCallWithError(FfiConverterTypeClientError_lift) {
      uniffi_edgefirst_client_fn_method_client_logout(
        self.uniffiCloneHandle(), $0
      )
    }
  }

  /**
   * Clear authentication token and log out (async).
   */
  open func logoutAsync() async throws {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_logout_async(
            self.uniffiCloneHandle()

          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_void,
        completeFunc: ffi_edgefirst_client_rust_future_complete_void,
        freeFunc: ffi_edgefirst_client_rust_future_free_void,
        liftFunc: { $0 },
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Get the current user's organization.
   */
  open func organization() throws -> Organization {
    return try FfiConverterTypeOrganization_lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_organization(
          self.uniffiCloneHandle(), $0
        )
      })
  }

  /**
   * Get the current user's organization (async).
   */
  open func organizationAsync() async throws -> Organization {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_organization_async(
            self.uniffiCloneHandle()

          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterTypeOrganization_lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Get a project by ID.
   */
  open func project(id: ProjectId) throws -> Project {
    return try FfiConverterTypeProject_lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_project(
          self.uniffiCloneHandle(),
          FfiConverterTypeProjectId_lower(id), $0
        )
      })
  }

  /**
   * Get a project by ID (async).
   */
  open func projectAsync(id: ProjectId) async throws -> Project {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_project_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeProjectId_lower(id)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterTypeProject_lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * List projects, optionally filtered by name.
   */
  open func projects(name: String?) throws -> [Project] {
    return try FfiConverterSequenceTypeProject.lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_projects(
          self.uniffiCloneHandle(),
          FfiConverterOptionString.lower(name), $0
        )
      })
  }

  /**
   * List projects, optionally filtered by name (async).
   */
  open func projectsAsync(name: String?) async throws -> [Project] {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_projects_async(
            self.uniffiCloneHandle(),
            FfiConverterOptionString.lower(name)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterSequenceTypeProject.lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Get a snapshot by ID.
   */
  open func snapshot(id: SnapshotId) throws -> Snapshot {
    return try FfiConverterTypeSnapshot_lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_snapshot(
          self.uniffiCloneHandle(),
          FfiConverterTypeSnapshotId_lower(id), $0
        )
      })
  }

  /**
   * Get a snapshot by ID (async).
   */
  open func snapshotAsync(id: SnapshotId) async throws -> Snapshot {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_snapshot_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeSnapshotId_lower(id)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterTypeSnapshot_lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * List snapshots, optionally filtered by name.
   */
  open func snapshots(name: String?) throws -> [Snapshot] {
    return try FfiConverterSequenceTypeSnapshot.lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_snapshots(
          self.uniffiCloneHandle(),
          FfiConverterOptionString.lower(name), $0
        )
      })
  }

  /**
   * List snapshots, optionally filtered by name (async).
   */
  open func snapshotsAsync(name: String?) async throws -> [Snapshot] {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_snapshots_async(
            self.uniffiCloneHandle(),
            FfiConverterOptionString.lower(name)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterSequenceTypeSnapshot.lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Get task information by ID.
   */
  open func taskInfo(id: TaskId) throws -> TaskInfo {
    return try FfiConverterTypeTaskInfo_lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_task_info(
          self.uniffiCloneHandle(),
          FfiConverterTypeTaskId_lower(id), $0
        )
      })
  }

  /**
   * Get task information by ID (async).
   */
  open func taskInfoAsync(id: TaskId) async throws -> TaskInfo {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_task_info_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeTaskId_lower(id)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterTypeTaskInfo_lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Get a training session by ID.
   */
  open func trainingSession(id: TrainingSessionId) throws -> TrainingSession {
    return try FfiConverterTypeTrainingSession_lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_training_session(
          self.uniffiCloneHandle(),
          FfiConverterTypeTrainingSessionId_lower(id), $0
        )
      })
  }

  /**
   * Get a training session by ID (async).
   */
  open func trainingSessionAsync(id: TrainingSessionId) async throws -> TrainingSession {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_training_session_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeTrainingSessionId_lower(id)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterTypeTrainingSession_lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * List training sessions in an experiment, optionally filtered by name.
   */
  open func trainingSessions(experimentId: ExperimentId, name: String?) throws -> [TrainingSession]
  {
    return try FfiConverterSequenceTypeTrainingSession.lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_training_sessions(
          self.uniffiCloneHandle(),
          FfiConverterTypeExperimentId_lower(experimentId),
          FfiConverterOptionString.lower(name), $0
        )
      })
  }

  /**
   * List training sessions in an experiment (async).
   */
  open func trainingSessionsAsync(experimentId: ExperimentId, name: String?) async throws
    -> [TrainingSession]
  {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_training_sessions_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeExperimentId_lower(experimentId), FfiConverterOptionString.lower(name)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterSequenceTypeTrainingSession.lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Get the current server URL.
   */
  open func url() -> String {
    return try! FfiConverterString.lift(
      try! rustCall {
        uniffi_edgefirst_client_fn_method_client_url(
          self.uniffiCloneHandle(), $0
        )
      })
  }

  /**
   * List validation sessions for a project.
   */
  open func validationSessions(projectId: ProjectId) throws -> [ValidationSession] {
    return try FfiConverterSequenceTypeValidationSession.lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_validation_sessions(
          self.uniffiCloneHandle(),
          FfiConverterTypeProjectId_lower(projectId), $0
        )
      })
  }

  /**
   * List validation sessions for a project (async).
   */
  open func validationSessionsAsync(projectId: ProjectId) async throws -> [ValidationSession] {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_validation_sessions_async(
            self.uniffiCloneHandle(),
            FfiConverterTypeProjectId_lower(projectId)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
        completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
        freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
        liftFunc: FfiConverterSequenceTypeValidationSession.lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Verify that the current token is valid.
   */
  open func verifyToken() throws {
    try rustCallWithError(FfiConverterTypeClientError_lift) {
      uniffi_edgefirst_client_fn_method_client_verify_token(
        self.uniffiCloneHandle(), $0
      )
    }
  }

  /**
   * Verify that the current token is valid (async).
   */
  open func verifyTokenAsync() async throws {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_verify_token_async(
            self.uniffiCloneHandle()

          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_void,
        completeFunc: ffi_edgefirst_client_rust_future_complete_void,
        freeFunc: ffi_edgefirst_client_rust_future_free_void,
        liftFunc: { $0 },
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Authenticate with username and password (blocking).
   */
  open func withLogin(username: String, password: String) throws -> Client {
    return try FfiConverterTypeClient_lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_with_login(
          self.uniffiCloneHandle(),
          FfiConverterString.lower(username),
          FfiConverterString.lower(password), $0
        )
      })
  }

  /**
   * Authenticate with username and password (async).
   *
   * Uses `async-compat` to enter Tokio context for reqwest compatibility
   * while allowing UniFFI to drive the future from Swift/Kotlin.
   */
  open func withLoginAsync(username: String, password: String) async throws -> Client {
    return
      try await uniffiRustCallAsync(
        rustFutureFunc: {
          uniffi_edgefirst_client_fn_method_client_with_login_async(
            self.uniffiCloneHandle(),
            FfiConverterString.lower(username), FfiConverterString.lower(password)
          )
        },
        pollFunc: ffi_edgefirst_client_rust_future_poll_u64,
        completeFunc: ffi_edgefirst_client_rust_future_complete_u64,
        freeFunc: ffi_edgefirst_client_rust_future_free_u64,
        liftFunc: FfiConverterTypeClient_lift,
        errorHandler: FfiConverterTypeClientError_lift
      )
  }

  /**
   * Returns a new client connected to the specified server instance.
   *
   * Server names: "" or "saas" → production, "test", "stage", "dev", or
   * custom.
   */
  open func withServer(name: String) throws -> Client {
    return try FfiConverterTypeClient_lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_with_server(
          self.uniffiCloneHandle(),
          FfiConverterString.lower(name), $0
        )
      })
  }

  /**
   * Returns a new client with the specified authentication token.
   */
  open func withToken(token: String) throws -> Client {
    return try FfiConverterTypeClient_lift(
      try rustCallWithError(FfiConverterTypeClientError_lift) {
        uniffi_edgefirst_client_fn_method_client_with_token(
          self.uniffiCloneHandle(),
          FfiConverterString.lower(token), $0
        )
      })
  }

}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeClient: FfiConverter {
  typealias FfiType = UInt64
  typealias SwiftType = Client

  public static func lift(_ handle: UInt64) throws -> Client {
    return Client(unsafeFromHandle: handle)
  }

  public static func lower(_ value: Client) -> UInt64 {
    return value.uniffiCloneHandle()
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
    let handle: UInt64 = try readInt(&buf)
    return try lift(handle)
  }

  public static func write(_ value: Client, into buf: inout [UInt8]) {
    writeInt(&buf, lower(value))
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lift(_ handle: UInt64) throws -> Client {
  return try FfiConverterTypeClient.lift(handle)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lower(_ value: Client) -> UInt64 {
  return FfiConverterTypeClient.lower(value)
}

/// An annotation on a sample (bounding box, mask, etc.).
public struct Annotation: Equatable, Hashable {
  /**
   * Sample this annotation belongs to.
   */
  public let sampleId: SampleId?
  /**
   * Image/sample name.
   */
  public let name: String?
  /**
   * Sequence this annotation belongs to.
   */
  public let sequenceName: String?
  /**
   * Frame number within the sequence.
   */
  public let frameNumber: UInt32?
  /**
   * Dataset split (train, val, test).
   */
  public let group: String?
  /**
   * Object tracking identifier across frames.
   */
  public let objectId: String?
  /**
   * Label/class name.
   */
  public let labelName: String?
  /**
   * Label/class index.
   */
  public let labelIndex: UInt64?
  /**
   * 2D bounding box.
   */
  public let box2d: Box2d?
  /**
   * 3D bounding box.
   */
  public let box3d: Box3d?
  /**
   * Segmentation mask.
   */
  public let mask: Mask?

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(
    /**
     * Sample this annotation belongs to.
     */
    sampleId: SampleId?,
    /**
     * Image/sample name.
     */
    name: String?,
    /**
     * Sequence this annotation belongs to.
     */
    sequenceName: String?,
    /**
     * Frame number within the sequence.
     */
    frameNumber: UInt32?,
    /**
     * Dataset split (train, val, test).
     */
    group: String?,
    /**
     * Object tracking identifier across frames.
     */
    objectId: String?,
    /**
     * Label/class name.
     */
    labelName: String?,
    /**
     * Label/class index.
     */
    labelIndex: UInt64?,
    /**
     * 2D bounding box.
     */
    box2d: Box2d?,
    /**
     * 3D bounding box.
     */
    box3d: Box3d?,
    /**
     * Segmentation mask.
     */
    mask: Mask?
  ) {
    self.sampleId = sampleId
    self.name = name
    self.sequenceName = sequenceName
    self.frameNumber = frameNumber
    self.group = group
    self.objectId = objectId
    self.labelName = labelName
    self.labelIndex = labelIndex
    self.box2d = box2d
    self.box3d = box3d
    self.mask = mask
  }

}

#if compiler(>=6)
  extension Annotation: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotation: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Annotation {
    return
      try Annotation(
        sampleId: FfiConverterOptionTypeSampleId.read(from: &buf),
        name: FfiConverterOptionString.read(from: &buf),
        sequenceName: FfiConverterOptionString.read(from: &buf),
        frameNumber: FfiConverterOptionUInt32.read(from: &buf),
        group: FfiConverterOptionString.read(from: &buf),
        objectId: FfiConverterOptionString.read(from: &buf),
        labelName: FfiConverterOptionString.read(from: &buf),
        labelIndex: FfiConverterOptionUInt64.read(from: &buf),
        box2d: FfiConverterOptionTypeBox2d.read(from: &buf),
        box3d: FfiConverterOptionTypeBox3d.read(from: &buf),
        mask: FfiConverterOptionTypeMask.read(from: &buf)
      )
  }

  public static func write(_ value: Annotation, into buf: inout [UInt8]) {
    FfiConverterOptionTypeSampleId.write(value.sampleId, into: &buf)
    FfiConverterOptionString.write(value.name, into: &buf)
    FfiConverterOptionString.write(value.sequenceName, into: &buf)
    FfiConverterOptionUInt32.write(value.frameNumber, into: &buf)
    FfiConverterOptionString.write(value.group, into: &buf)
    FfiConverterOptionString.write(value.objectId, into: &buf)
    FfiConverterOptionString.write(value.labelName, into: &buf)
    FfiConverterOptionUInt64.write(value.labelIndex, into: &buf)
    FfiConverterOptionTypeBox2d.write(value.box2d, into: &buf)
    FfiConverterOptionTypeBox3d.write(value.box3d, into: &buf)
    FfiConverterOptionTypeMask.write(value.mask, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotation_lift(_ buf: RustBuffer) throws -> Annotation {
  return try FfiConverterTypeAnnotation.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotation_lower(_ value: Annotation) -> RustBuffer {
  return FfiConverterTypeAnnotation.lower(value)
}

/// An annotation set in a dataset.
public struct AnnotationSet: Equatable, Hashable {
  public let id: AnnotationSetId
  public let datasetId: DatasetId
  public let name: String
  public let description: String
  public let created: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(
    id: AnnotationSetId, datasetId: DatasetId, name: String, description: String, created: String
  ) {
    self.id = id
    self.datasetId = datasetId
    self.name = name
    self.description = description
    self.created = created
  }

}

#if compiler(>=6)
  extension AnnotationSet: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotationSet: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnnotationSet
  {
    return
      try AnnotationSet(
        id: FfiConverterTypeAnnotationSetId.read(from: &buf),
        datasetId: FfiConverterTypeDatasetId.read(from: &buf),
        name: FfiConverterString.read(from: &buf),
        description: FfiConverterString.read(from: &buf),
        created: FfiConverterString.read(from: &buf)
      )
  }

  public static func write(_ value: AnnotationSet, into buf: inout [UInt8]) {
    FfiConverterTypeAnnotationSetId.write(value.id, into: &buf)
    FfiConverterTypeDatasetId.write(value.datasetId, into: &buf)
    FfiConverterString.write(value.name, into: &buf)
    FfiConverterString.write(value.description, into: &buf)
    FfiConverterString.write(value.created, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationSet_lift(_ buf: RustBuffer) throws -> AnnotationSet {
  return try FfiConverterTypeAnnotationSet.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationSet_lower(_ value: AnnotationSet) -> RustBuffer {
  return FfiConverterTypeAnnotationSet.lower(value)
}

/// Unique identifier for an annotation set.
public struct AnnotationSetId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension AnnotationSetId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotationSetId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws
    -> AnnotationSetId
  {
    return
      try AnnotationSetId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: AnnotationSetId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationSetId_lift(_ buf: RustBuffer) throws -> AnnotationSetId {
  return try FfiConverterTypeAnnotationSetId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationSetId_lower(_ value: AnnotationSetId) -> RustBuffer {
  return FfiConverterTypeAnnotationSetId.lower(value)
}

/// Unique identifier for an application.
public struct AppId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension AppId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppId {
    return
      try AppId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: AppId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeAppId_lift(_ buf: RustBuffer) throws -> AppId {
  return try FfiConverterTypeAppId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeAppId_lower(_ value: AppId) -> RustBuffer {
  return FfiConverterTypeAppId.lower(value)
}

/// A model artifact from a training session.
public struct Artifact: Equatable, Hashable {
  public let name: String
  public let modelType: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(name: String, modelType: String) {
    self.name = name
    self.modelType = modelType
  }

}

#if compiler(>=6)
  extension Artifact: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeArtifact: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Artifact {
    return
      try Artifact(
        name: FfiConverterString.read(from: &buf),
        modelType: FfiConverterString.read(from: &buf)
      )
  }

  public static func write(_ value: Artifact, into buf: inout [UInt8]) {
    FfiConverterString.write(value.name, into: &buf)
    FfiConverterString.write(value.modelType, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeArtifact_lift(_ buf: RustBuffer) throws -> Artifact {
  return try FfiConverterTypeArtifact.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeArtifact_lower(_ value: Artifact) -> RustBuffer {
  return FfiConverterTypeArtifact.lower(value)
}

/// 2D bounding box annotation.
public struct Box2d: Equatable, Hashable {
  public let left: Float
  public let top: Float
  public let width: Float
  public let height: Float

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(left: Float, top: Float, width: Float, height: Float) {
    self.left = left
    self.top = top
    self.width = width
    self.height = height
  }

}

#if compiler(>=6)
  extension Box2d: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBox2d: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Box2d {
    return
      try Box2d(
        left: FfiConverterFloat.read(from: &buf),
        top: FfiConverterFloat.read(from: &buf),
        width: FfiConverterFloat.read(from: &buf),
        height: FfiConverterFloat.read(from: &buf)
      )
  }

  public static func write(_ value: Box2d, into buf: inout [UInt8]) {
    FfiConverterFloat.write(value.left, into: &buf)
    FfiConverterFloat.write(value.top, into: &buf)
    FfiConverterFloat.write(value.width, into: &buf)
    FfiConverterFloat.write(value.height, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeBox2d_lift(_ buf: RustBuffer) throws -> Box2d {
  return try FfiConverterTypeBox2d.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeBox2d_lower(_ value: Box2d) -> RustBuffer {
  return FfiConverterTypeBox2d.lower(value)
}

/// 3D bounding box annotation.
public struct Box3d: Equatable, Hashable {
  public let cx: Float
  public let cy: Float
  public let cz: Float
  public let width: Float
  public let height: Float
  public let length: Float

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(cx: Float, cy: Float, cz: Float, width: Float, height: Float, length: Float) {
    self.cx = cx
    self.cy = cy
    self.cz = cz
    self.width = width
    self.height = height
    self.length = length
  }

}

#if compiler(>=6)
  extension Box3d: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBox3d: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Box3d {
    return
      try Box3d(
        cx: FfiConverterFloat.read(from: &buf),
        cy: FfiConverterFloat.read(from: &buf),
        cz: FfiConverterFloat.read(from: &buf),
        width: FfiConverterFloat.read(from: &buf),
        height: FfiConverterFloat.read(from: &buf),
        length: FfiConverterFloat.read(from: &buf)
      )
  }

  public static func write(_ value: Box3d, into buf: inout [UInt8]) {
    FfiConverterFloat.write(value.cx, into: &buf)
    FfiConverterFloat.write(value.cy, into: &buf)
    FfiConverterFloat.write(value.cz, into: &buf)
    FfiConverterFloat.write(value.width, into: &buf)
    FfiConverterFloat.write(value.height, into: &buf)
    FfiConverterFloat.write(value.length, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeBox3d_lift(_ buf: RustBuffer) throws -> Box3d {
  return try FfiConverterTypeBox3d.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeBox3d_lower(_ value: Box3d) -> RustBuffer {
  return FfiConverterTypeBox3d.lower(value)
}

/// A dataset in EdgeFirst Studio.
public struct Dataset: Equatable, Hashable {
  public let id: DatasetId
  public let projectId: ProjectId
  public let name: String
  public let description: String
  public let created: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(
    id: DatasetId, projectId: ProjectId, name: String, description: String, created: String
  ) {
    self.id = id
    self.projectId = projectId
    self.name = name
    self.description = description
    self.created = created
  }

}

#if compiler(>=6)
  extension Dataset: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeDataset: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Dataset {
    return
      try Dataset(
        id: FfiConverterTypeDatasetId.read(from: &buf),
        projectId: FfiConverterTypeProjectId.read(from: &buf),
        name: FfiConverterString.read(from: &buf),
        description: FfiConverterString.read(from: &buf),
        created: FfiConverterString.read(from: &buf)
      )
  }

  public static func write(_ value: Dataset, into buf: inout [UInt8]) {
    FfiConverterTypeDatasetId.write(value.id, into: &buf)
    FfiConverterTypeProjectId.write(value.projectId, into: &buf)
    FfiConverterString.write(value.name, into: &buf)
    FfiConverterString.write(value.description, into: &buf)
    FfiConverterString.write(value.created, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeDataset_lift(_ buf: RustBuffer) throws -> Dataset {
  return try FfiConverterTypeDataset.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeDataset_lower(_ value: Dataset) -> RustBuffer {
  return FfiConverterTypeDataset.lower(value)
}

/// Unique identifier for a dataset.
public struct DatasetId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension DatasetId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeDatasetId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DatasetId {
    return
      try DatasetId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: DatasetId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeDatasetId_lift(_ buf: RustBuffer) throws -> DatasetId {
  return try FfiConverterTypeDatasetId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeDatasetId_lower(_ value: DatasetId) -> RustBuffer {
  return FfiConverterTypeDatasetId.lower(value)
}

/// An experiment in EdgeFirst Studio.
public struct Experiment: Equatable, Hashable {
  public let id: ExperimentId
  public let projectId: ProjectId
  public let name: String
  public let description: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(id: ExperimentId, projectId: ProjectId, name: String, description: String) {
    self.id = id
    self.projectId = projectId
    self.name = name
    self.description = description
  }

}

#if compiler(>=6)
  extension Experiment: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeExperiment: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Experiment {
    return
      try Experiment(
        id: FfiConverterTypeExperimentId.read(from: &buf),
        projectId: FfiConverterTypeProjectId.read(from: &buf),
        name: FfiConverterString.read(from: &buf),
        description: FfiConverterString.read(from: &buf)
      )
  }

  public static func write(_ value: Experiment, into buf: inout [UInt8]) {
    FfiConverterTypeExperimentId.write(value.id, into: &buf)
    FfiConverterTypeProjectId.write(value.projectId, into: &buf)
    FfiConverterString.write(value.name, into: &buf)
    FfiConverterString.write(value.description, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeExperiment_lift(_ buf: RustBuffer) throws -> Experiment {
  return try FfiConverterTypeExperiment.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeExperiment_lower(_ value: Experiment) -> RustBuffer {
  return FfiConverterTypeExperiment.lower(value)
}

/// Unique identifier for an experiment.
public struct ExperimentId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension ExperimentId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeExperimentId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExperimentId {
    return
      try ExperimentId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: ExperimentId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeExperimentId_lift(_ buf: RustBuffer) throws -> ExperimentId {
  return try FfiConverterTypeExperimentId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeExperimentId_lower(_ value: ExperimentId) -> RustBuffer {
  return FfiConverterTypeExperimentId.lower(value)
}

/// GPS location data.
public struct GpsData: Equatable, Hashable {
  public let lat: Double
  public let lon: Double

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(lat: Double, lon: Double) {
    self.lat = lat
    self.lon = lon
  }

}

#if compiler(>=6)
  extension GpsData: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeGpsData: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GpsData {
    return
      try GpsData(
        lat: FfiConverterDouble.read(from: &buf),
        lon: FfiConverterDouble.read(from: &buf)
      )
  }

  public static func write(_ value: GpsData, into buf: inout [UInt8]) {
    FfiConverterDouble.write(value.lat, into: &buf)
    FfiConverterDouble.write(value.lon, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeGpsData_lift(_ buf: RustBuffer) throws -> GpsData {
  return try FfiConverterTypeGpsData.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeGpsData_lower(_ value: GpsData) -> RustBuffer {
  return FfiConverterTypeGpsData.lower(value)
}

/// Unique identifier for an image.
public struct ImageId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension ImageId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeImageId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageId {
    return
      try ImageId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: ImageId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeImageId_lift(_ buf: RustBuffer) throws -> ImageId {
  return try FfiConverterTypeImageId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeImageId_lower(_ value: ImageId) -> RustBuffer {
  return FfiConverterTypeImageId.lower(value)
}

/// IMU orientation data (roll, pitch, yaw in degrees).
public struct ImuData: Equatable, Hashable {
  public let roll: Double
  public let pitch: Double
  public let yaw: Double

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(roll: Double, pitch: Double, yaw: Double) {
    self.roll = roll
    self.pitch = pitch
    self.yaw = yaw
  }

}

#if compiler(>=6)
  extension ImuData: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeImuData: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImuData {
    return
      try ImuData(
        roll: FfiConverterDouble.read(from: &buf),
        pitch: FfiConverterDouble.read(from: &buf),
        yaw: FfiConverterDouble.read(from: &buf)
      )
  }

  public static func write(_ value: ImuData, into buf: inout [UInt8]) {
    FfiConverterDouble.write(value.roll, into: &buf)
    FfiConverterDouble.write(value.pitch, into: &buf)
    FfiConverterDouble.write(value.yaw, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeImuData_lift(_ buf: RustBuffer) throws -> ImuData {
  return try FfiConverterTypeImuData.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeImuData_lower(_ value: ImuData) -> RustBuffer {
  return FfiConverterTypeImuData.lower(value)
}

/// A label for annotations.
public struct Label: Equatable, Hashable {
  public let id: UInt64
  public let name: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(id: UInt64, name: String) {
    self.id = id
    self.name = name
  }

}

#if compiler(>=6)
  extension Label: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLabel: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Label {
    return
      try Label(
        id: FfiConverterUInt64.read(from: &buf),
        name: FfiConverterString.read(from: &buf)
      )
  }

  public static func write(_ value: Label, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.id, into: &buf)
    FfiConverterString.write(value.name, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeLabel_lift(_ buf: RustBuffer) throws -> Label {
  return try FfiConverterTypeLabel.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeLabel_lower(_ value: Label) -> RustBuffer {
  return FfiConverterTypeLabel.lower(value)
}

/// Location and pose information for a sample.
public struct Location: Equatable, Hashable {
  /**
   * GPS coordinates (latitude, longitude).
   */
  public let gps: GpsData?
  /**
   * IMU orientation (roll, pitch, yaw).
   */
  public let imu: ImuData?

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(
    /**
     * GPS coordinates (latitude, longitude).
     */
    gps: GpsData?,
    /**
     * IMU orientation (roll, pitch, yaw).
     */
    imu: ImuData?
  ) {
    self.gps = gps
    self.imu = imu
  }

}

#if compiler(>=6)
  extension Location: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocation: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Location {
    return
      try Location(
        gps: FfiConverterOptionTypeGpsData.read(from: &buf),
        imu: FfiConverterOptionTypeImuData.read(from: &buf)
      )
  }

  public static func write(_ value: Location, into buf: inout [UInt8]) {
    FfiConverterOptionTypeGpsData.write(value.gps, into: &buf)
    FfiConverterOptionTypeImuData.write(value.imu, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeLocation_lift(_ buf: RustBuffer) throws -> Location {
  return try FfiConverterTypeLocation.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeLocation_lower(_ value: Location) -> RustBuffer {
  return FfiConverterTypeLocation.lower(value)
}

/// Segmentation mask as a list of polygon rings.
///
/// Each ring is a closed polygon defined by a sequence of (x, y) coordinates.
/// Multiple rings allow for complex shapes with holes.
public struct Mask: Equatable, Hashable {
  public let polygon: [PolygonRing]

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(polygon: [PolygonRing]) {
    self.polygon = polygon
  }

}

#if compiler(>=6)
  extension Mask: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeMask: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mask {
    return
      try Mask(
        polygon: FfiConverterSequenceTypePolygonRing.read(from: &buf)
      )
  }

  public static func write(_ value: Mask, into buf: inout [UInt8]) {
    FfiConverterSequenceTypePolygonRing.write(value.polygon, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeMask_lift(_ buf: RustBuffer) throws -> Mask {
  return try FfiConverterTypeMask.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeMask_lower(_ value: Mask) -> RustBuffer {
  return FfiConverterTypeMask.lower(value)
}

/// Organization information and metadata.
public struct Organization: Equatable, Hashable {
  public let id: OrganizationId
  public let name: String
  public let credits: Int64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(id: OrganizationId, name: String, credits: Int64) {
    self.id = id
    self.name = name
    self.credits = credits
  }

}

#if compiler(>=6)
  extension Organization: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeOrganization: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Organization {
    return
      try Organization(
        id: FfiConverterTypeOrganizationId.read(from: &buf),
        name: FfiConverterString.read(from: &buf),
        credits: FfiConverterInt64.read(from: &buf)
      )
  }

  public static func write(_ value: Organization, into buf: inout [UInt8]) {
    FfiConverterTypeOrganizationId.write(value.id, into: &buf)
    FfiConverterString.write(value.name, into: &buf)
    FfiConverterInt64.write(value.credits, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeOrganization_lift(_ buf: RustBuffer) throws -> Organization {
  return try FfiConverterTypeOrganization.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeOrganization_lower(_ value: Organization) -> RustBuffer {
  return FfiConverterTypeOrganization.lower(value)
}

/// Unique identifier for an organization.
public struct OrganizationId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension OrganizationId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeOrganizationId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrganizationId
  {
    return
      try OrganizationId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: OrganizationId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeOrganizationId_lift(_ buf: RustBuffer) throws -> OrganizationId {
  return try FfiConverterTypeOrganizationId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeOrganizationId_lower(_ value: OrganizationId) -> RustBuffer {
  return FfiConverterTypeOrganizationId.lower(value)
}

/// A 2D point (x, y coordinates).
public struct Point2d: Equatable, Hashable {
  public let x: Float
  public let y: Float

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(x: Float, y: Float) {
    self.x = x
    self.y = y
  }

}

#if compiler(>=6)
  extension Point2d: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypePoint2d: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Point2d {
    return
      try Point2d(
        x: FfiConverterFloat.read(from: &buf),
        y: FfiConverterFloat.read(from: &buf)
      )
  }

  public static func write(_ value: Point2d, into buf: inout [UInt8]) {
    FfiConverterFloat.write(value.x, into: &buf)
    FfiConverterFloat.write(value.y, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypePoint2d_lift(_ buf: RustBuffer) throws -> Point2d {
  return try FfiConverterTypePoint2d.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypePoint2d_lower(_ value: Point2d) -> RustBuffer {
  return FfiConverterTypePoint2d.lower(value)
}

/// A polygon ring as a list of 2D points.
public struct PolygonRing: Equatable, Hashable {
  public let points: [Point2d]

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(points: [Point2d]) {
    self.points = points
  }

}

#if compiler(>=6)
  extension PolygonRing: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypePolygonRing: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PolygonRing {
    return
      try PolygonRing(
        points: FfiConverterSequenceTypePoint2d.read(from: &buf)
      )
  }

  public static func write(_ value: PolygonRing, into buf: inout [UInt8]) {
    FfiConverterSequenceTypePoint2d.write(value.points, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypePolygonRing_lift(_ buf: RustBuffer) throws -> PolygonRing {
  return try FfiConverterTypePolygonRing.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypePolygonRing_lower(_ value: PolygonRing) -> RustBuffer {
  return FfiConverterTypePolygonRing.lower(value)
}

/// A project in EdgeFirst Studio.
public struct Project: Equatable, Hashable {
  public let id: ProjectId
  public let name: String
  public let description: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(id: ProjectId, name: String, description: String) {
    self.id = id
    self.name = name
    self.description = description
  }

}

#if compiler(>=6)
  extension Project: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeProject: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Project {
    return
      try Project(
        id: FfiConverterTypeProjectId.read(from: &buf),
        name: FfiConverterString.read(from: &buf),
        description: FfiConverterString.read(from: &buf)
      )
  }

  public static func write(_ value: Project, into buf: inout [UInt8]) {
    FfiConverterTypeProjectId.write(value.id, into: &buf)
    FfiConverterString.write(value.name, into: &buf)
    FfiConverterString.write(value.description, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeProject_lift(_ buf: RustBuffer) throws -> Project {
  return try FfiConverterTypeProject.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeProject_lower(_ value: Project) -> RustBuffer {
  return FfiConverterTypeProject.lower(value)
}

/// Unique identifier for a project.
public struct ProjectId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension ProjectId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeProjectId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProjectId {
    return
      try ProjectId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: ProjectId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectId_lift(_ buf: RustBuffer) throws -> ProjectId {
  return try FfiConverterTypeProjectId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectId_lower(_ value: ProjectId) -> RustBuffer {
  return FfiConverterTypeProjectId.lower(value)
}

/// A sample in a dataset (image with metadata and annotations).
public struct Sample: Equatable, Hashable {
  /**
   * Unique sample identifier.
   */
  public let id: SampleId?
  /**
   * Dataset split (train, val, test).
   */
  public let group: String?
  /**
   * Sequence name for video/temporal data.
   */
  public let sequenceName: String?
  /**
   * Sequence UUID.
   */
  public let sequenceUuid: String?
  /**
   * Sequence description.
   */
  public let sequenceDescription: String?
  /**
   * Frame number within the sequence.
   */
  public let frameNumber: UInt32?
  /**
   * Sample UUID.
   */
  public let uuid: String?
  /**
   * Primary image filename.
   */
  public let imageName: String?
  /**
   * URL to download the primary image.
   */
  public let imageUrl: String?
  /**
   * Image width in pixels.
   */
  public let width: UInt32?
  /**
   * Image height in pixels.
   */
  public let height: UInt32?
  /**
   * Capture date/time (ISO 8601 format).
   */
  public let date: String?
  /**
   * Data source identifier.
   */
  public let source: String?
  /**
   * Camera location and pose.
   */
  public let location: Location?
  /**
   * Image degradation type (blur, occlusion, weather, etc.).
   */
  public let degradation: String?
  /**
   * Additional sensor files (LiDAR, radar, etc.).
   */
  public let files: [SampleFile]
  /**
   * Annotations on this sample.
   */
  public let annotations: [Annotation]

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(
    /**
     * Unique sample identifier.
     */
    id: SampleId?,
    /**
     * Dataset split (train, val, test).
     */
    group: String?,
    /**
     * Sequence name for video/temporal data.
     */
    sequenceName: String?,
    /**
     * Sequence UUID.
     */
    sequenceUuid: String?,
    /**
     * Sequence description.
     */
    sequenceDescription: String?,
    /**
     * Frame number within the sequence.
     */
    frameNumber: UInt32?,
    /**
     * Sample UUID.
     */
    uuid: String?,
    /**
     * Primary image filename.
     */
    imageName: String?,
    /**
     * URL to download the primary image.
     */
    imageUrl: String?,
    /**
     * Image width in pixels.
     */
    width: UInt32?,
    /**
     * Image height in pixels.
     */
    height: UInt32?,
    /**
     * Capture date/time (ISO 8601 format).
     */
    date: String?,
    /**
     * Data source identifier.
     */
    source: String?,
    /**
     * Camera location and pose.
     */
    location: Location?,
    /**
     * Image degradation type (blur, occlusion, weather, etc.).
     */
    degradation: String?,
    /**
     * Additional sensor files (LiDAR, radar, etc.).
     */
    files: [SampleFile],
    /**
     * Annotations on this sample.
     */
    annotations: [Annotation]
  ) {
    self.id = id
    self.group = group
    self.sequenceName = sequenceName
    self.sequenceUuid = sequenceUuid
    self.sequenceDescription = sequenceDescription
    self.frameNumber = frameNumber
    self.uuid = uuid
    self.imageName = imageName
    self.imageUrl = imageUrl
    self.width = width
    self.height = height
    self.date = date
    self.source = source
    self.location = location
    self.degradation = degradation
    self.files = files
    self.annotations = annotations
  }

}

#if compiler(>=6)
  extension Sample: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSample: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Sample {
    return
      try Sample(
        id: FfiConverterOptionTypeSampleId.read(from: &buf),
        group: FfiConverterOptionString.read(from: &buf),
        sequenceName: FfiConverterOptionString.read(from: &buf),
        sequenceUuid: FfiConverterOptionString.read(from: &buf),
        sequenceDescription: FfiConverterOptionString.read(from: &buf),
        frameNumber: FfiConverterOptionUInt32.read(from: &buf),
        uuid: FfiConverterOptionString.read(from: &buf),
        imageName: FfiConverterOptionString.read(from: &buf),
        imageUrl: FfiConverterOptionString.read(from: &buf),
        width: FfiConverterOptionUInt32.read(from: &buf),
        height: FfiConverterOptionUInt32.read(from: &buf),
        date: FfiConverterOptionString.read(from: &buf),
        source: FfiConverterOptionString.read(from: &buf),
        location: FfiConverterOptionTypeLocation.read(from: &buf),
        degradation: FfiConverterOptionString.read(from: &buf),
        files: FfiConverterSequenceTypeSampleFile.read(from: &buf),
        annotations: FfiConverterSequenceTypeAnnotation.read(from: &buf)
      )
  }

  public static func write(_ value: Sample, into buf: inout [UInt8]) {
    FfiConverterOptionTypeSampleId.write(value.id, into: &buf)
    FfiConverterOptionString.write(value.group, into: &buf)
    FfiConverterOptionString.write(value.sequenceName, into: &buf)
    FfiConverterOptionString.write(value.sequenceUuid, into: &buf)
    FfiConverterOptionString.write(value.sequenceDescription, into: &buf)
    FfiConverterOptionUInt32.write(value.frameNumber, into: &buf)
    FfiConverterOptionString.write(value.uuid, into: &buf)
    FfiConverterOptionString.write(value.imageName, into: &buf)
    FfiConverterOptionString.write(value.imageUrl, into: &buf)
    FfiConverterOptionUInt32.write(value.width, into: &buf)
    FfiConverterOptionUInt32.write(value.height, into: &buf)
    FfiConverterOptionString.write(value.date, into: &buf)
    FfiConverterOptionString.write(value.source, into: &buf)
    FfiConverterOptionTypeLocation.write(value.location, into: &buf)
    FfiConverterOptionString.write(value.degradation, into: &buf)
    FfiConverterSequenceTypeSampleFile.write(value.files, into: &buf)
    FfiConverterSequenceTypeAnnotation.write(value.annotations, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeSample_lift(_ buf: RustBuffer) throws -> Sample {
  return try FfiConverterTypeSample.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeSample_lower(_ value: Sample) -> RustBuffer {
  return FfiConverterTypeSample.lower(value)
}

/// A file associated with a sample (e.g., LiDAR point cloud, radar data).
public struct SampleFile: Equatable, Hashable {
  /**
   * File type identifier (e.g., "lidar_pcd", "radar_cube").
   */
  public let fileType: String
  /**
   * URL to download the file (present for retrieved samples).
   */
  public let url: String?
  /**
   * Local filename (used when populating samples).
   */
  public let filename: String?

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(
    /**
     * File type identifier (e.g., "lidar_pcd", "radar_cube").
     */
    fileType: String,
    /**
     * URL to download the file (present for retrieved samples).
     */
    url: String?,
    /**
     * Local filename (used when populating samples).
     */
    filename: String?
  ) {
    self.fileType = fileType
    self.url = url
    self.filename = filename
  }

}

#if compiler(>=6)
  extension SampleFile: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSampleFile: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SampleFile {
    return
      try SampleFile(
        fileType: FfiConverterString.read(from: &buf),
        url: FfiConverterOptionString.read(from: &buf),
        filename: FfiConverterOptionString.read(from: &buf)
      )
  }

  public static func write(_ value: SampleFile, into buf: inout [UInt8]) {
    FfiConverterString.write(value.fileType, into: &buf)
    FfiConverterOptionString.write(value.url, into: &buf)
    FfiConverterOptionString.write(value.filename, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeSampleFile_lift(_ buf: RustBuffer) throws -> SampleFile {
  return try FfiConverterTypeSampleFile.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeSampleFile_lower(_ value: SampleFile) -> RustBuffer {
  return FfiConverterTypeSampleFile.lower(value)
}

/// Unique identifier for a sample.
public struct SampleId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension SampleId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSampleId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SampleId {
    return
      try SampleId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: SampleId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeSampleId_lift(_ buf: RustBuffer) throws -> SampleId {
  return try FfiConverterTypeSampleId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeSampleId_lower(_ value: SampleId) -> RustBuffer {
  return FfiConverterTypeSampleId.lower(value)
}

/// Unique identifier for a sequence.
public struct SequenceId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension SequenceId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSequenceId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SequenceId {
    return
      try SequenceId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: SequenceId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeSequenceId_lift(_ buf: RustBuffer) throws -> SequenceId {
  return try FfiConverterTypeSequenceId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeSequenceId_lower(_ value: SequenceId) -> RustBuffer {
  return FfiConverterTypeSequenceId.lower(value)
}

/// A snapshot in EdgeFirst Studio.
public struct Snapshot: Equatable, Hashable {
  public let id: SnapshotId
  public let description: String
  public let status: String
  public let path: String
  public let created: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(id: SnapshotId, description: String, status: String, path: String, created: String) {
    self.id = id
    self.description = description
    self.status = status
    self.path = path
    self.created = created
  }

}

#if compiler(>=6)
  extension Snapshot: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSnapshot: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Snapshot {
    return
      try Snapshot(
        id: FfiConverterTypeSnapshotId.read(from: &buf),
        description: FfiConverterString.read(from: &buf),
        status: FfiConverterString.read(from: &buf),
        path: FfiConverterString.read(from: &buf),
        created: FfiConverterString.read(from: &buf)
      )
  }

  public static func write(_ value: Snapshot, into buf: inout [UInt8]) {
    FfiConverterTypeSnapshotId.write(value.id, into: &buf)
    FfiConverterString.write(value.description, into: &buf)
    FfiConverterString.write(value.status, into: &buf)
    FfiConverterString.write(value.path, into: &buf)
    FfiConverterString.write(value.created, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeSnapshot_lift(_ buf: RustBuffer) throws -> Snapshot {
  return try FfiConverterTypeSnapshot.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeSnapshot_lower(_ value: Snapshot) -> RustBuffer {
  return FfiConverterTypeSnapshot.lower(value)
}

/// Unique identifier for a snapshot.
public struct SnapshotId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension SnapshotId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSnapshotId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SnapshotId {
    return
      try SnapshotId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: SnapshotId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeSnapshotId_lift(_ buf: RustBuffer) throws -> SnapshotId {
  return try FfiConverterTypeSnapshotId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeSnapshotId_lower(_ value: SnapshotId) -> RustBuffer {
  return FfiConverterTypeSnapshotId.lower(value)
}

/// A stage in a task's progress.
public struct Stage: Equatable, Hashable {
  public let stage: String
  public let status: String?
  public let message: String?
  public let percentage: UInt8

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(stage: String, status: String?, message: String?, percentage: UInt8) {
    self.stage = stage
    self.status = status
    self.message = message
    self.percentage = percentage
  }

}

#if compiler(>=6)
  extension Stage: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeStage: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Stage {
    return
      try Stage(
        stage: FfiConverterString.read(from: &buf),
        status: FfiConverterOptionString.read(from: &buf),
        message: FfiConverterOptionString.read(from: &buf),
        percentage: FfiConverterUInt8.read(from: &buf)
      )
  }

  public static func write(_ value: Stage, into buf: inout [UInt8]) {
    FfiConverterString.write(value.stage, into: &buf)
    FfiConverterOptionString.write(value.status, into: &buf)
    FfiConverterOptionString.write(value.message, into: &buf)
    FfiConverterUInt8.write(value.percentage, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeStage_lift(_ buf: RustBuffer) throws -> Stage {
  return try FfiConverterTypeStage.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeStage_lower(_ value: Stage) -> RustBuffer {
  return FfiConverterTypeStage.lower(value)
}

/// A task in EdgeFirst Studio.
public struct Task: Equatable, Hashable {
  public let id: TaskId
  public let name: String
  public let workflow: String
  public let status: String
  public let manager: String?
  public let instance: String
  public let created: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(
    id: TaskId, name: String, workflow: String, status: String, manager: String?, instance: String,
    created: String
  ) {
    self.id = id
    self.name = name
    self.workflow = workflow
    self.status = status
    self.manager = manager
    self.instance = instance
    self.created = created
  }

}

#if compiler(>=6)
  extension Task: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeTask: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Task {
    return
      try Task(
        id: FfiConverterTypeTaskId.read(from: &buf),
        name: FfiConverterString.read(from: &buf),
        workflow: FfiConverterString.read(from: &buf),
        status: FfiConverterString.read(from: &buf),
        manager: FfiConverterOptionString.read(from: &buf),
        instance: FfiConverterString.read(from: &buf),
        created: FfiConverterString.read(from: &buf)
      )
  }

  public static func write(_ value: Task, into buf: inout [UInt8]) {
    FfiConverterTypeTaskId.write(value.id, into: &buf)
    FfiConverterString.write(value.name, into: &buf)
    FfiConverterString.write(value.workflow, into: &buf)
    FfiConverterString.write(value.status, into: &buf)
    FfiConverterOptionString.write(value.manager, into: &buf)
    FfiConverterString.write(value.instance, into: &buf)
    FfiConverterString.write(value.created, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeTask_lift(_ buf: RustBuffer) throws -> Task {
  return try FfiConverterTypeTask.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeTask_lower(_ value: Task) -> RustBuffer {
  return FfiConverterTypeTask.lower(value)
}

/// Unique identifier for a task.
public struct TaskId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension TaskId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeTaskId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TaskId {
    return
      try TaskId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: TaskId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeTaskId_lift(_ buf: RustBuffer) throws -> TaskId {
  return try FfiConverterTypeTaskId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeTaskId_lower(_ value: TaskId) -> RustBuffer {
  return FfiConverterTypeTaskId.lower(value)
}

/// Detailed task information.
public struct TaskInfo: Equatable, Hashable {
  public let id: TaskId
  public let projectId: ProjectId?
  public let description: String
  public let workflow: String
  public let status: String?
  public let created: String
  public let completed: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(
    id: TaskId, projectId: ProjectId?, description: String, workflow: String, status: String?,
    created: String, completed: String
  ) {
    self.id = id
    self.projectId = projectId
    self.description = description
    self.workflow = workflow
    self.status = status
    self.created = created
    self.completed = completed
  }

}

#if compiler(>=6)
  extension TaskInfo: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeTaskInfo: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TaskInfo {
    return
      try TaskInfo(
        id: FfiConverterTypeTaskId.read(from: &buf),
        projectId: FfiConverterOptionTypeProjectId.read(from: &buf),
        description: FfiConverterString.read(from: &buf),
        workflow: FfiConverterString.read(from: &buf),
        status: FfiConverterOptionString.read(from: &buf),
        created: FfiConverterString.read(from: &buf),
        completed: FfiConverterString.read(from: &buf)
      )
  }

  public static func write(_ value: TaskInfo, into buf: inout [UInt8]) {
    FfiConverterTypeTaskId.write(value.id, into: &buf)
    FfiConverterOptionTypeProjectId.write(value.projectId, into: &buf)
    FfiConverterString.write(value.description, into: &buf)
    FfiConverterString.write(value.workflow, into: &buf)
    FfiConverterOptionString.write(value.status, into: &buf)
    FfiConverterString.write(value.created, into: &buf)
    FfiConverterString.write(value.completed, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeTaskInfo_lift(_ buf: RustBuffer) throws -> TaskInfo {
  return try FfiConverterTypeTaskInfo.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeTaskInfo_lower(_ value: TaskInfo) -> RustBuffer {
  return FfiConverterTypeTaskInfo.lower(value)
}

/// A training session in an experiment.
public struct TrainingSession: Equatable, Hashable {
  public let id: TrainingSessionId
  public let experimentId: ExperimentId
  public let name: String
  public let description: String
  public let model: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(
    id: TrainingSessionId, experimentId: ExperimentId, name: String, description: String,
    model: String
  ) {
    self.id = id
    self.experimentId = experimentId
    self.name = name
    self.description = description
    self.model = model
  }

}

#if compiler(>=6)
  extension TrainingSession: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeTrainingSession: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws
    -> TrainingSession
  {
    return
      try TrainingSession(
        id: FfiConverterTypeTrainingSessionId.read(from: &buf),
        experimentId: FfiConverterTypeExperimentId.read(from: &buf),
        name: FfiConverterString.read(from: &buf),
        description: FfiConverterString.read(from: &buf),
        model: FfiConverterString.read(from: &buf)
      )
  }

  public static func write(_ value: TrainingSession, into buf: inout [UInt8]) {
    FfiConverterTypeTrainingSessionId.write(value.id, into: &buf)
    FfiConverterTypeExperimentId.write(value.experimentId, into: &buf)
    FfiConverterString.write(value.name, into: &buf)
    FfiConverterString.write(value.description, into: &buf)
    FfiConverterString.write(value.model, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeTrainingSession_lift(_ buf: RustBuffer) throws -> TrainingSession {
  return try FfiConverterTypeTrainingSession.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeTrainingSession_lower(_ value: TrainingSession) -> RustBuffer {
  return FfiConverterTypeTrainingSession.lower(value)
}

/// Unique identifier for a training session.
public struct TrainingSessionId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension TrainingSessionId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeTrainingSessionId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws
    -> TrainingSessionId
  {
    return
      try TrainingSessionId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: TrainingSessionId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeTrainingSessionId_lift(_ buf: RustBuffer) throws -> TrainingSessionId {
  return try FfiConverterTypeTrainingSessionId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeTrainingSessionId_lower(_ value: TrainingSessionId) -> RustBuffer {
  return FfiConverterTypeTrainingSessionId.lower(value)
}

/// A validation session in an experiment.
public struct ValidationSession: Equatable, Hashable {
  public let id: ValidationSessionId
  public let experimentId: ExperimentId
  public let trainingSessionId: TrainingSessionId
  public let datasetId: DatasetId
  public let annotationSetId: AnnotationSetId
  public let description: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(
    id: ValidationSessionId, experimentId: ExperimentId, trainingSessionId: TrainingSessionId,
    datasetId: DatasetId, annotationSetId: AnnotationSetId, description: String
  ) {
    self.id = id
    self.experimentId = experimentId
    self.trainingSessionId = trainingSessionId
    self.datasetId = datasetId
    self.annotationSetId = annotationSetId
    self.description = description
  }

}

#if compiler(>=6)
  extension ValidationSession: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeValidationSession: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws
    -> ValidationSession
  {
    return
      try ValidationSession(
        id: FfiConverterTypeValidationSessionId.read(from: &buf),
        experimentId: FfiConverterTypeExperimentId.read(from: &buf),
        trainingSessionId: FfiConverterTypeTrainingSessionId.read(from: &buf),
        datasetId: FfiConverterTypeDatasetId.read(from: &buf),
        annotationSetId: FfiConverterTypeAnnotationSetId.read(from: &buf),
        description: FfiConverterString.read(from: &buf)
      )
  }

  public static func write(_ value: ValidationSession, into buf: inout [UInt8]) {
    FfiConverterTypeValidationSessionId.write(value.id, into: &buf)
    FfiConverterTypeExperimentId.write(value.experimentId, into: &buf)
    FfiConverterTypeTrainingSessionId.write(value.trainingSessionId, into: &buf)
    FfiConverterTypeDatasetId.write(value.datasetId, into: &buf)
    FfiConverterTypeAnnotationSetId.write(value.annotationSetId, into: &buf)
    FfiConverterString.write(value.description, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationSession_lift(_ buf: RustBuffer) throws -> ValidationSession {
  return try FfiConverterTypeValidationSession.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationSession_lower(_ value: ValidationSession) -> RustBuffer {
  return FfiConverterTypeValidationSession.lower(value)
}

/// Unique identifier for a validation session.
public struct ValidationSessionId: Equatable, Hashable {
  public let value: UInt64

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(value: UInt64) {
    self.value = value
  }

}

#if compiler(>=6)
  extension ValidationSessionId: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeValidationSessionId: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws
    -> ValidationSessionId
  {
    return
      try ValidationSessionId(
        value: FfiConverterUInt64.read(from: &buf)
      )
  }

  public static func write(_ value: ValidationSessionId, into buf: inout [UInt8]) {
    FfiConverterUInt64.write(value.value, into: &buf)
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationSessionId_lift(_ buf: RustBuffer) throws
  -> ValidationSessionId
{
  return try FfiConverterTypeValidationSessionId.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationSessionId_lower(_ value: ValidationSessionId) -> RustBuffer {
  return FfiConverterTypeValidationSessionId.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Annotation types supported for labeling data.
 */

public enum AnnotationType: Equatable, Hashable {

  /**
   * 2D bounding boxes for object detection in images
   */
  case box2d
  /**
   * 3D bounding boxes for object detection in 3D space
   */
  case box3d
  /**
   * Pixel-level segmentation masks
   */
  case mask

}

#if compiler(>=6)
  extension AnnotationType: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotationType: FfiConverterRustBuffer {
  typealias SwiftType = AnnotationType

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnnotationType
  {
    let variant: Int32 = try readInt(&buf)
    switch variant {

    case 1: return .box2d

    case 2: return .box3d

    case 3: return .mask

    default: throw UniffiInternalError.unexpectedEnumCase
    }
  }

  public static func write(_ value: AnnotationType, into buf: inout [UInt8]) {
    switch value {

    case .box2d:
      writeInt(&buf, Int32(1))

    case .box3d:
      writeInt(&buf, Int32(2))

    case .mask:
      writeInt(&buf, Int32(3))

    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationType_lift(_ buf: RustBuffer) throws -> AnnotationType {
  return try FfiConverterTypeAnnotationType.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationType_lower(_ value: AnnotationType) -> RustBuffer {
  return FfiConverterTypeAnnotationType.lower(value)
}

/// Error type for client operations.
public enum ClientError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

  /**
   * Authentication failed or token is invalid/expired.
   */
  case AuthenticationError(
    message: String
  )
  /**
   * Network or HTTP error.
   */
  case NetworkError(
    message: String
  )
  /**
   * Invalid parameters provided to an operation.
   */
  case InvalidParameters(
    message: String
  )
  /**
   * Requested resource was not found.
   */
  case NotFound(
    message: String
  )
  /**
   * Token storage operation failed.
   */
  case StorageError(
    message: String
  )
  /**
   * Internal error or unexpected condition.
   */
  case InternalError(
    message: String
  )

  public var errorDescription: String? {
    String(reflecting: self)
  }

}

#if compiler(>=6)
  extension ClientError: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
  typealias SwiftType = ClientError

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
    let variant: Int32 = try readInt(&buf)
    switch variant {

    case 1:
      return .AuthenticationError(
        message: try FfiConverterString.read(from: &buf)
      )
    case 2:
      return .NetworkError(
        message: try FfiConverterString.read(from: &buf)
      )
    case 3:
      return .InvalidParameters(
        message: try FfiConverterString.read(from: &buf)
      )
    case 4:
      return .NotFound(
        message: try FfiConverterString.read(from: &buf)
      )
    case 5:
      return .StorageError(
        message: try FfiConverterString.read(from: &buf)
      )
    case 6:
      return .InternalError(
        message: try FfiConverterString.read(from: &buf)
      )

    default: throw UniffiInternalError.unexpectedEnumCase
    }
  }

  public static func write(_ value: ClientError, into buf: inout [UInt8]) {
    switch value {

    case .AuthenticationError(let message):
      writeInt(&buf, Int32(1))
      FfiConverterString.write(message, into: &buf)

    case .NetworkError(let message):
      writeInt(&buf, Int32(2))
      FfiConverterString.write(message, into: &buf)

    case .InvalidParameters(let message):
      writeInt(&buf, Int32(3))
      FfiConverterString.write(message, into: &buf)

    case .NotFound(let message):
      writeInt(&buf, Int32(4))
      FfiConverterString.write(message, into: &buf)

    case .StorageError(let message):
      writeInt(&buf, Int32(5))
      FfiConverterString.write(message, into: &buf)

    case .InternalError(let message):
      writeInt(&buf, Int32(6))
      FfiConverterString.write(message, into: &buf)

    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeClientError_lift(_ buf: RustBuffer) throws -> ClientError {
  return try FfiConverterTypeClientError.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeClientError_lower(_ value: ClientError) -> RustBuffer {
  return FfiConverterTypeClientError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * File types supported in EdgeFirst Studio datasets.
 */

public enum FileType: Equatable, Hashable {

  /**
   * Standard image files (JPEG, PNG, etc.)
   */
  case image
  /**
   * LiDAR point cloud data files (.pcd format)
   */
  case lidarPcd
  /**
   * LiDAR depth images (.png format)
   */
  case lidarDepth
  /**
   * LiDAR reflectance images (.jpg format)
   */
  case lidarReflect
  /**
   * Radar point cloud data files (.pcd format)
   */
  case radarPcd
  /**
   * Radar cube data files (.png format)
   */
  case radarCube

}

#if compiler(>=6)
  extension FileType: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileType: FfiConverterRustBuffer {
  typealias SwiftType = FileType

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileType {
    let variant: Int32 = try readInt(&buf)
    switch variant {

    case 1: return .image

    case 2: return .lidarPcd

    case 3: return .lidarDepth

    case 4: return .lidarReflect

    case 5: return .radarPcd

    case 6: return .radarCube

    default: throw UniffiInternalError.unexpectedEnumCase
    }
  }

  public static func write(_ value: FileType, into buf: inout [UInt8]) {
    switch value {

    case .image:
      writeInt(&buf, Int32(1))

    case .lidarPcd:
      writeInt(&buf, Int32(2))

    case .lidarDepth:
      writeInt(&buf, Int32(3))

    case .lidarReflect:
      writeInt(&buf, Int32(4))

    case .radarPcd:
      writeInt(&buf, Int32(5))

    case .radarCube:
      writeInt(&buf, Int32(6))

    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeFileType_lift(_ buf: RustBuffer) throws -> FileType {
  return try FfiConverterTypeFileType.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeFileType_lower(_ value: FileType) -> RustBuffer {
  return FfiConverterTypeFileType.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Generic parameter value used in API requests and configuration.
 */

public enum Parameter: Equatable, Hashable {

  /**
   * 64-bit signed integer value.
   */
  case integer(
    value: Int64
  )
  /**
   * 64-bit floating-point value.
   */
  case real(
    value: Double
  )
  /**
   * Boolean true/false value.
   */
  case boolean(
    value: Bool
  )
  /**
   * UTF-8 string value.
   */
  case string(
    value: String
  )
  /**
   * Array of nested parameter values.
   */
  case array(
    values: [Parameter]
  )
  /**
   * Object/map with string keys and parameter values.
   */
  case object(
    entries: [String: Parameter]
  )

}

#if compiler(>=6)
  extension Parameter: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeParameter: FfiConverterRustBuffer {
  typealias SwiftType = Parameter

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Parameter {
    let variant: Int32 = try readInt(&buf)
    switch variant {

    case 1:
      return .integer(
        value: try FfiConverterInt64.read(from: &buf)
      )

    case 2:
      return .real(
        value: try FfiConverterDouble.read(from: &buf)
      )

    case 3:
      return .boolean(
        value: try FfiConverterBool.read(from: &buf)
      )

    case 4:
      return .string(
        value: try FfiConverterString.read(from: &buf)
      )

    case 5:
      return .array(
        values: try FfiConverterSequenceTypeParameter.read(from: &buf)
      )

    case 6:
      return .object(
        entries: try FfiConverterDictionaryStringTypeParameter.read(from: &buf)
      )

    default: throw UniffiInternalError.unexpectedEnumCase
    }
  }

  public static func write(_ value: Parameter, into buf: inout [UInt8]) {
    switch value {

    case .integer(let value):
      writeInt(&buf, Int32(1))
      FfiConverterInt64.write(value, into: &buf)

    case .real(let value):
      writeInt(&buf, Int32(2))
      FfiConverterDouble.write(value, into: &buf)

    case .boolean(let value):
      writeInt(&buf, Int32(3))
      FfiConverterBool.write(value, into: &buf)

    case .string(let value):
      writeInt(&buf, Int32(4))
      FfiConverterString.write(value, into: &buf)

    case .array(let values):
      writeInt(&buf, Int32(5))
      FfiConverterSequenceTypeParameter.write(values, into: &buf)

    case .object(let entries):
      writeInt(&buf, Int32(6))
      FfiConverterDictionaryStringTypeParameter.write(entries, into: &buf)

    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeParameter_lift(_ buf: RustBuffer) throws -> Parameter {
  return try FfiConverterTypeParameter.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeParameter_lower(_ value: Parameter) -> RustBuffer {
  return FfiConverterTypeParameter.lower(value)
}

/// Error type for token storage operations.
public enum StorageError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

  /**
   * Storage is not available (e.g., cannot determine config directory).
   */
  case NotAvailable(
    message: String
  )
  /**
   * Failed to read token from storage.
   */
  case ReadError(
    message: String
  )
  /**
   * Failed to write token to storage.
   */
  case WriteError(
    message: String
  )
  /**
   * Failed to clear token from storage.
   */
  case ClearError(
    message: String
  )

  public var errorDescription: String? {
    String(reflecting: self)
  }

}

#if compiler(>=6)
  extension StorageError: Sendable {}
#endif

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageError: FfiConverterRustBuffer {
  typealias SwiftType = StorageError

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageError {
    let variant: Int32 = try readInt(&buf)
    switch variant {

    case 1:
      return .NotAvailable(
        message: try FfiConverterString.read(from: &buf)
      )
    case 2:
      return .ReadError(
        message: try FfiConverterString.read(from: &buf)
      )
    case 3:
      return .WriteError(
        message: try FfiConverterString.read(from: &buf)
      )
    case 4:
      return .ClearError(
        message: try FfiConverterString.read(from: &buf)
      )

    default: throw UniffiInternalError.unexpectedEnumCase
    }
  }

  public static func write(_ value: StorageError, into buf: inout [UInt8]) {
    switch value {

    case .NotAvailable(let message):
      writeInt(&buf, Int32(1))
      FfiConverterString.write(message, into: &buf)

    case .ReadError(let message):
      writeInt(&buf, Int32(2))
      FfiConverterString.write(message, into: &buf)

    case .WriteError(let message):
      writeInt(&buf, Int32(3))
      FfiConverterString.write(message, into: &buf)

    case .ClearError(let message):
      writeInt(&buf, Int32(4))
      FfiConverterString.write(message, into: &buf)

    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageError_lift(_ buf: RustBuffer) throws -> StorageError {
  return try FfiConverterTypeStorageError.lift(buf)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageError_lower(_ value: StorageError) -> RustBuffer {
  return FfiConverterTypeStorageError.lower(value)
}

/// Trait for persistent token storage.
///
/// Implement this interface in Kotlin/Swift to provide platform-specific
/// secure token storage (e.g., Android Keystore, iOS Keychain).
public protocol TokenStorage: AnyObject, Sendable {

  /**
   * Store the authentication token.
   */
  func store(token: String) throws

  /**
   * Load the stored authentication token.
   * Returns `None` if no token is stored.
   */
  func load() throws -> String?

  /**
   * Clear the stored authentication token.
   */
  func clear() throws

}

// Put the implementation in a struct so we don't pollute the top-level namespace
private struct UniffiCallbackInterfaceTokenStorage {

  // Create the VTable using a series of closures.
  // Swift automatically converts these into C callback functions.
  //
  // This creates 1-element array, since this seems to be the only way to construct a const
  // pointer that we can pass to the Rust code.
  static let vtable: [UniffiVTableCallbackInterfaceTokenStorage] = [
    UniffiVTableCallbackInterfaceTokenStorage(
      uniffiFree: { (uniffiHandle: UInt64) -> Void in
        do {
          try FfiConverterCallbackInterfaceTokenStorage.handleMap.remove(handle: uniffiHandle)
        } catch {
          print("Uniffi callback interface TokenStorage: handle missing in uniffiFree")
        }
      },
      uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
        do {
          return try FfiConverterCallbackInterfaceTokenStorage.handleMap.clone(handle: uniffiHandle)
        } catch {
          fatalError("Uniffi callback interface TokenStorage: handle missing in uniffiClone")
        }
      },
      store: {
        (
          uniffiHandle: UInt64,
          token: RustBuffer,
          uniffiOutReturn: UnsafeMutableRawPointer,
          uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
        let makeCall = {
          () throws -> Void in
          guard
            let uniffiObj = try? FfiConverterCallbackInterfaceTokenStorage.handleMap.get(
              handle: uniffiHandle)
          else {
            throw UniffiInternalError.unexpectedStaleHandle
          }
          return try uniffiObj.store(
            token: try FfiConverterString.lift(token)
          )
        }

        let writeReturn = { () }
        uniffiTraitInterfaceCallWithError(
          callStatus: uniffiCallStatus,
          makeCall: makeCall,
          writeReturn: writeReturn,
          lowerError: FfiConverterTypeStorageError_lower
        )
      },
      load: {
        (
          uniffiHandle: UInt64,
          uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
          uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
        let makeCall = {
          () throws -> String? in
          guard
            let uniffiObj = try? FfiConverterCallbackInterfaceTokenStorage.handleMap.get(
              handle: uniffiHandle)
          else {
            throw UniffiInternalError.unexpectedStaleHandle
          }
          return try uniffiObj.load()
        }

        let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionString.lower($0) }
        uniffiTraitInterfaceCallWithError(
          callStatus: uniffiCallStatus,
          makeCall: makeCall,
          writeReturn: writeReturn,
          lowerError: FfiConverterTypeStorageError_lower
        )
      },
      clear: {
        (
          uniffiHandle: UInt64,
          uniffiOutReturn: UnsafeMutableRawPointer,
          uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
        let makeCall = {
          () throws -> Void in
          guard
            let uniffiObj = try? FfiConverterCallbackInterfaceTokenStorage.handleMap.get(
              handle: uniffiHandle)
          else {
            throw UniffiInternalError.unexpectedStaleHandle
          }
          return try uniffiObj.clear()
        }

        let writeReturn = { () }
        uniffiTraitInterfaceCallWithError(
          callStatus: uniffiCallStatus,
          makeCall: makeCall,
          writeReturn: writeReturn,
          lowerError: FfiConverterTypeStorageError_lower
        )
      }
    )
  ]
}

private func uniffiCallbackInitTokenStorage() {
  uniffi_edgefirst_client_fn_init_callback_vtable_tokenstorage(
    UniffiCallbackInterfaceTokenStorage.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterCallbackInterfaceTokenStorage {
  fileprivate static let handleMap = UniffiHandleMap<TokenStorage>()
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceTokenStorage: FfiConverter {
  typealias SwiftType = TokenStorage
  typealias FfiType = UInt64

  #if swift(>=5.8)
    @_documentation(visibility: private)
  #endif
  public static func lift(_ handle: UInt64) throws -> SwiftType {
    try handleMap.get(handle: handle)
  }

  #if swift(>=5.8)
    @_documentation(visibility: private)
  #endif
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
    let handle: UInt64 = try readInt(&buf)
    return try lift(handle)
  }

  #if swift(>=5.8)
    @_documentation(visibility: private)
  #endif
  public static func lower(_ v: SwiftType) -> UInt64 {
    return handleMap.insert(obj: v)
  }

  #if swift(>=5.8)
    @_documentation(visibility: private)
  #endif
  public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
    writeInt(&buf, lower(v))
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceTokenStorage_lift(_ handle: UInt64) throws -> TokenStorage
{
  return try FfiConverterCallbackInterfaceTokenStorage.lift(handle)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceTokenStorage_lower(_ v: TokenStorage) -> UInt64 {
  return FfiConverterCallbackInterfaceTokenStorage.lower(v)
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
  typealias SwiftType = UInt32?

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    guard let value = value else {
      writeInt(&buf, Int8(0))
      return
    }
    writeInt(&buf, Int8(1))
    FfiConverterUInt32.write(value, into: &buf)
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
    switch try readInt(&buf) as Int8 {
    case 0: return nil
    case 1: return try FfiConverterUInt32.read(from: &buf)
    default: throw UniffiInternalError.unexpectedOptionalTag
    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
  typealias SwiftType = UInt64?

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    guard let value = value else {
      writeInt(&buf, Int8(0))
      return
    }
    writeInt(&buf, Int8(1))
    FfiConverterUInt64.write(value, into: &buf)
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
    switch try readInt(&buf) as Int8 {
    case 0: return nil
    case 1: return try FfiConverterUInt64.read(from: &buf)
    default: throw UniffiInternalError.unexpectedOptionalTag
    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterOptionString: FfiConverterRustBuffer {
  typealias SwiftType = String?

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    guard let value = value else {
      writeInt(&buf, Int8(0))
      return
    }
    writeInt(&buf, Int8(1))
    FfiConverterString.write(value, into: &buf)
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
    switch try readInt(&buf) as Int8 {
    case 0: return nil
    case 1: return try FfiConverterString.read(from: &buf)
    default: throw UniffiInternalError.unexpectedOptionalTag
    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeBox2d: FfiConverterRustBuffer {
  typealias SwiftType = Box2d?

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    guard let value = value else {
      writeInt(&buf, Int8(0))
      return
    }
    writeInt(&buf, Int8(1))
    FfiConverterTypeBox2d.write(value, into: &buf)
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
    switch try readInt(&buf) as Int8 {
    case 0: return nil
    case 1: return try FfiConverterTypeBox2d.read(from: &buf)
    default: throw UniffiInternalError.unexpectedOptionalTag
    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeBox3d: FfiConverterRustBuffer {
  typealias SwiftType = Box3d?

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    guard let value = value else {
      writeInt(&buf, Int8(0))
      return
    }
    writeInt(&buf, Int8(1))
    FfiConverterTypeBox3d.write(value, into: &buf)
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
    switch try readInt(&buf) as Int8 {
    case 0: return nil
    case 1: return try FfiConverterTypeBox3d.read(from: &buf)
    default: throw UniffiInternalError.unexpectedOptionalTag
    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeGpsData: FfiConverterRustBuffer {
  typealias SwiftType = GpsData?

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    guard let value = value else {
      writeInt(&buf, Int8(0))
      return
    }
    writeInt(&buf, Int8(1))
    FfiConverterTypeGpsData.write(value, into: &buf)
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
    switch try readInt(&buf) as Int8 {
    case 0: return nil
    case 1: return try FfiConverterTypeGpsData.read(from: &buf)
    default: throw UniffiInternalError.unexpectedOptionalTag
    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeImuData: FfiConverterRustBuffer {
  typealias SwiftType = ImuData?

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    guard let value = value else {
      writeInt(&buf, Int8(0))
      return
    }
    writeInt(&buf, Int8(1))
    FfiConverterTypeImuData.write(value, into: &buf)
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
    switch try readInt(&buf) as Int8 {
    case 0: return nil
    case 1: return try FfiConverterTypeImuData.read(from: &buf)
    default: throw UniffiInternalError.unexpectedOptionalTag
    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeLocation: FfiConverterRustBuffer {
  typealias SwiftType = Location?

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    guard let value = value else {
      writeInt(&buf, Int8(0))
      return
    }
    writeInt(&buf, Int8(1))
    FfiConverterTypeLocation.write(value, into: &buf)
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
    switch try readInt(&buf) as Int8 {
    case 0: return nil
    case 1: return try FfiConverterTypeLocation.read(from: &buf)
    default: throw UniffiInternalError.unexpectedOptionalTag
    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeMask: FfiConverterRustBuffer {
  typealias SwiftType = Mask?

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    guard let value = value else {
      writeInt(&buf, Int8(0))
      return
    }
    writeInt(&buf, Int8(1))
    FfiConverterTypeMask.write(value, into: &buf)
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
    switch try readInt(&buf) as Int8 {
    case 0: return nil
    case 1: return try FfiConverterTypeMask.read(from: &buf)
    default: throw UniffiInternalError.unexpectedOptionalTag
    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeProjectId: FfiConverterRustBuffer {
  typealias SwiftType = ProjectId?

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    guard let value = value else {
      writeInt(&buf, Int8(0))
      return
    }
    writeInt(&buf, Int8(1))
    FfiConverterTypeProjectId.write(value, into: &buf)
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
    switch try readInt(&buf) as Int8 {
    case 0: return nil
    case 1: return try FfiConverterTypeProjectId.read(from: &buf)
    default: throw UniffiInternalError.unexpectedOptionalTag
    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeSampleId: FfiConverterRustBuffer {
  typealias SwiftType = SampleId?

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    guard let value = value else {
      writeInt(&buf, Int8(0))
      return
    }
    writeInt(&buf, Int8(1))
    FfiConverterTypeSampleId.write(value, into: &buf)
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
    switch try readInt(&buf) as Int8 {
    case 0: return nil
    case 1: return try FfiConverterTypeSampleId.read(from: &buf)
    default: throw UniffiInternalError.unexpectedOptionalTag
    }
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeAnnotation: FfiConverterRustBuffer {
  typealias SwiftType = [Annotation]

  public static func write(_ value: [Annotation], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypeAnnotation.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Annotation] {
    let len: Int32 = try readInt(&buf)
    var seq = [Annotation]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypeAnnotation.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeAnnotationSet: FfiConverterRustBuffer {
  typealias SwiftType = [AnnotationSet]

  public static func write(_ value: [AnnotationSet], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypeAnnotationSet.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws
    -> [AnnotationSet]
  {
    let len: Int32 = try readInt(&buf)
    var seq = [AnnotationSet]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypeAnnotationSet.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeArtifact: FfiConverterRustBuffer {
  typealias SwiftType = [Artifact]

  public static func write(_ value: [Artifact], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypeArtifact.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Artifact] {
    let len: Int32 = try readInt(&buf)
    var seq = [Artifact]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypeArtifact.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeDataset: FfiConverterRustBuffer {
  typealias SwiftType = [Dataset]

  public static func write(_ value: [Dataset], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypeDataset.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Dataset] {
    let len: Int32 = try readInt(&buf)
    var seq = [Dataset]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypeDataset.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeExperiment: FfiConverterRustBuffer {
  typealias SwiftType = [Experiment]

  public static func write(_ value: [Experiment], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypeExperiment.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Experiment] {
    let len: Int32 = try readInt(&buf)
    var seq = [Experiment]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypeExperiment.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeLabel: FfiConverterRustBuffer {
  typealias SwiftType = [Label]

  public static func write(_ value: [Label], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypeLabel.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Label] {
    let len: Int32 = try readInt(&buf)
    var seq = [Label]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypeLabel.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypePoint2d: FfiConverterRustBuffer {
  typealias SwiftType = [Point2d]

  public static func write(_ value: [Point2d], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypePoint2d.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Point2d] {
    let len: Int32 = try readInt(&buf)
    var seq = [Point2d]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypePoint2d.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypePolygonRing: FfiConverterRustBuffer {
  typealias SwiftType = [PolygonRing]

  public static func write(_ value: [PolygonRing], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypePolygonRing.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PolygonRing]
  {
    let len: Int32 = try readInt(&buf)
    var seq = [PolygonRing]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypePolygonRing.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeProject: FfiConverterRustBuffer {
  typealias SwiftType = [Project]

  public static func write(_ value: [Project], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypeProject.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Project] {
    let len: Int32 = try readInt(&buf)
    var seq = [Project]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypeProject.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeSampleFile: FfiConverterRustBuffer {
  typealias SwiftType = [SampleFile]

  public static func write(_ value: [SampleFile], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypeSampleFile.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SampleFile] {
    let len: Int32 = try readInt(&buf)
    var seq = [SampleFile]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypeSampleFile.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeSnapshot: FfiConverterRustBuffer {
  typealias SwiftType = [Snapshot]

  public static func write(_ value: [Snapshot], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypeSnapshot.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Snapshot] {
    let len: Int32 = try readInt(&buf)
    var seq = [Snapshot]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypeSnapshot.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeTrainingSession: FfiConverterRustBuffer {
  typealias SwiftType = [TrainingSession]

  public static func write(_ value: [TrainingSession], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypeTrainingSession.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws
    -> [TrainingSession]
  {
    let len: Int32 = try readInt(&buf)
    var seq = [TrainingSession]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypeTrainingSession.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeValidationSession: FfiConverterRustBuffer {
  typealias SwiftType = [ValidationSession]

  public static func write(_ value: [ValidationSession], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypeValidationSession.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws
    -> [ValidationSession]
  {
    let len: Int32 = try readInt(&buf)
    var seq = [ValidationSession]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypeValidationSession.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeParameter: FfiConverterRustBuffer {
  typealias SwiftType = [Parameter]

  public static func write(_ value: [Parameter], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for item in value {
      FfiConverterTypeParameter.write(item, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Parameter] {
    let len: Int32 = try readInt(&buf)
    var seq = [Parameter]()
    seq.reserveCapacity(Int(len))
    for _ in 0..<len {
      seq.append(try FfiConverterTypeParameter.read(from: &buf))
    }
    return seq
  }
}

#if swift(>=5.8)
  @_documentation(visibility: private)
#endif
private struct FfiConverterDictionaryStringTypeParameter: FfiConverterRustBuffer {
  public static func write(_ value: [String: Parameter], into buf: inout [UInt8]) {
    let len = Int32(value.count)
    writeInt(&buf, len)
    for (key, value) in value {
      FfiConverterString.write(key, into: &buf)
      FfiConverterTypeParameter.write(value, into: &buf)
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String:
    Parameter]
  {
    let len: Int32 = try readInt(&buf)
    var dict = [String: Parameter]()
    dict.reserveCapacity(Int(len))
    for _ in 0..<len {
      let key = try FfiConverterString.read(from: &buf)
      let value = try FfiConverterTypeParameter.read(from: &buf)
      dict[key] = value
    }
    return dict
  }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_WAKE: Int8 = 1

private let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

private func uniffiRustCallAsync<F, T>(
  rustFutureFunc: () -> UInt64,
  pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> Void,
  completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
  freeFunc: (UInt64) -> Void,
  liftFunc: (F) throws -> T,
  errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
  // Make sure to call the ensure init function since future creation doesn't have a
  // RustCallStatus param, so doesn't use makeRustCall()
  uniffiEnsureEdgefirstClientInitialized()
  let rustFuture = rustFutureFunc()
  defer {
    freeFunc(rustFuture)
  }
  var pollResult: Int8
  repeat {
    pollResult = await withUnsafeContinuation {
      pollFunc(
        rustFuture,
        { handle, pollResult in
          uniffiFutureContinuationCallback(handle: handle, pollResult: pollResult)
        },
        uniffiContinuationHandleMap.insert(obj: $0)
      )
    }
  } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

  return try liftFunc(
    makeRustCall(
      { completeFunc(rustFuture, $0) },
      errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
  if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
    continuation.resume(returning: pollResult)
  } else {
    print("uniffiFutureContinuationCallback invalid handle")
  }
}
/// Create a new client with custom token storage.
///
/// Use this to provide platform-specific secure storage implementations.
///
/// # Example (Kotlin)
///
/// ```kotlin
/// class SecureStorage : TokenStorage {
/// override fun store(token: String) { /* ... */ }
/// override fun load(): String? { /* ... */ }
/// override fun clear() { /* ... */ }
/// }
///
/// val client = createClientWithStorage(SecureStorage())
/// ```
public func createClientWithStorage(storage: TokenStorage) throws -> Client {
  return try FfiConverterTypeClient_lift(
    try rustCallWithError(FfiConverterTypeClientError_lift) {
      uniffi_edgefirst_client_fn_func_create_client_with_storage(
        FfiConverterCallbackInterfaceTokenStorage_lower(storage), $0
      )
    })
}

private enum InitializationResult {
  case ok
  case contractVersionMismatch
  case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
  // Get the bindings contract version from our ComponentInterface
  let bindings_contract_version = 30
  // Get the scaffolding contract version by calling the into the dylib
  let scaffolding_contract_version = ffi_edgefirst_client_uniffi_contract_version()
  if bindings_contract_version != scaffolding_contract_version {
    return InitializationResult.contractVersionMismatch
  }
  if uniffi_edgefirst_client_checksum_func_create_client_with_storage() != 51357 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_annotation_sets() != 52667 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_annotation_sets_async() != 58035 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_artifacts() != 47017 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_artifacts_async() != 51396 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_dataset() != 15504 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_dataset_async() != 27919 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_datasets() != 57983 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_datasets_async() != 31737 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_experiment() != 51030 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_experiment_async() != 14274 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_experiments() != 20493 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_experiments_async() != 40764 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_labels() != 53854 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_labels_async() != 3030 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_logout() != 56266 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_logout_async() != 45796 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_organization() != 54001 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_organization_async() != 3202 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_project() != 33098 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_project_async() != 28720 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_projects() != 47045 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_projects_async() != 45294 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_snapshot() != 860 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_snapshot_async() != 3327 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_snapshots() != 57059 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_snapshots_async() != 36918 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_task_info() != 36680 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_task_info_async() != 13534 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_training_session() != 61626 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_training_session_async() != 20668 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_training_sessions() != 59773 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_training_sessions_async() != 60165 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_url() != 10365 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_validation_sessions() != 38295 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_validation_sessions_async() != 27882 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_verify_token() != 32558 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_verify_token_async() != 9022 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_with_login() != 31228 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_with_login_async() != 791 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_with_server() != 23777 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_client_with_token() != 51792 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_constructor_client_new() != 15084 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_constructor_client_with_memory_storage() != 34648 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_tokenstorage_store() != 32185 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_tokenstorage_load() != 6805 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_edgefirst_client_checksum_method_tokenstorage_clear() != 18446 {
    return InitializationResult.apiChecksumMismatch
  }

  uniffiCallbackInitTokenStorage()
  return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureEdgefirstClientInitialized() {
  switch initializationResult {
  case .ok:
    break
  case .contractVersionMismatch:
    fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
  case .apiChecksumMismatch:
    fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
}

// swiftlint:enable all
