// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(edgefirst_clientFFI)
import edgefirst_clientFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_edgefirst_client_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_edgefirst_client_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureEdgefirstClientInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




/**
 * Main client for interacting with EdgeFirst Studio.
 */
public protocol ClientProtocol: AnyObject, Sendable {
    
    /**
     * Get annotation sets for a dataset.
     */
    func annotationSets(datasetId: DatasetId) throws  -> [AnnotationSet]
    
    /**
     * Get annotation sets for a dataset (async).
     */
    func annotationSetsAsync(datasetId: DatasetId) async throws  -> [AnnotationSet]
    
    /**
     * Get artifacts for a training session.
     */
    func artifacts(trainingSessionId: TrainingSessionId) throws  -> [Artifact]
    
    /**
     * Get artifacts for a training session (async).
     */
    func artifactsAsync(trainingSessionId: TrainingSessionId) async throws  -> [Artifact]
    
    /**
     * Get a dataset by ID.
     */
    func dataset(id: DatasetId) throws  -> Dataset
    
    /**
     * Get a dataset by ID (async).
     */
    func datasetAsync(id: DatasetId) async throws  -> Dataset
    
    /**
     * List datasets in a project, optionally filtered by name.
     */
    func datasets(projectId: ProjectId, name: String?) throws  -> [Dataset]
    
    /**
     * List datasets in a project (async).
     */
    func datasetsAsync(projectId: ProjectId, name: String?) async throws  -> [Dataset]
    
    /**
     * Get an experiment by ID.
     */
    func experiment(id: ExperimentId) throws  -> Experiment
    
    /**
     * Get an experiment by ID (async).
     */
    func experimentAsync(id: ExperimentId) async throws  -> Experiment
    
    /**
     * List experiments in a project, optionally filtered by name.
     */
    func experiments(projectId: ProjectId, name: String?) throws  -> [Experiment]
    
    /**
     * List experiments in a project (async).
     */
    func experimentsAsync(projectId: ProjectId, name: String?) async throws  -> [Experiment]
    
    /**
     * Get labels for a dataset.
     */
    func labels(datasetId: DatasetId) throws  -> [Label]
    
    /**
     * Get labels for a dataset (async).
     */
    func labelsAsync(datasetId: DatasetId) async throws  -> [Label]
    
    /**
     * Clear authentication token and log out.
     */
    func logout() throws 
    
    /**
     * Clear authentication token and log out (async).
     */
    func logoutAsync() async throws 
    
    /**
     * Get the current user's organization.
     */
    func organization() throws  -> Organization
    
    /**
     * Get the current user's organization (async).
     */
    func organizationAsync() async throws  -> Organization
    
    /**
     * Get a project by ID.
     */
    func project(id: ProjectId) throws  -> Project
    
    /**
     * Get a project by ID (async).
     */
    func projectAsync(id: ProjectId) async throws  -> Project
    
    /**
     * List projects, optionally filtered by name.
     */
    func projects(name: String?) throws  -> [Project]
    
    /**
     * List projects, optionally filtered by name (async).
     */
    func projectsAsync(name: String?) async throws  -> [Project]
    
    /**
     * Get a snapshot by ID.
     */
    func snapshot(id: SnapshotId) throws  -> Snapshot
    
    /**
     * Get a snapshot by ID (async).
     */
    func snapshotAsync(id: SnapshotId) async throws  -> Snapshot
    
    /**
     * List snapshots, optionally filtered by name.
     */
    func snapshots(name: String?) throws  -> [Snapshot]
    
    /**
     * List snapshots, optionally filtered by name (async).
     */
    func snapshotsAsync(name: String?) async throws  -> [Snapshot]
    
    /**
     * Get task information by ID.
     */
    func taskInfo(id: TaskId) throws  -> TaskInfo
    
    /**
     * Get task information by ID (async).
     */
    func taskInfoAsync(id: TaskId) async throws  -> TaskInfo
    
    /**
     * Get a training session by ID.
     */
    func trainingSession(id: TrainingSessionId) throws  -> TrainingSession
    
    /**
     * Get a training session by ID (async).
     */
    func trainingSessionAsync(id: TrainingSessionId) async throws  -> TrainingSession
    
    /**
     * List training sessions in an experiment, optionally filtered by name.
     */
    func trainingSessions(experimentId: ExperimentId, name: String?) throws  -> [TrainingSession]
    
    /**
     * List training sessions in an experiment (async).
     */
    func trainingSessionsAsync(experimentId: ExperimentId, name: String?) async throws  -> [TrainingSession]
    
    /**
     * Get the current server URL.
     */
    func url()  -> String
    
    /**
     * List validation sessions for a project.
     */
    func validationSessions(projectId: ProjectId) throws  -> [ValidationSession]
    
    /**
     * List validation sessions for a project (async).
     */
    func validationSessionsAsync(projectId: ProjectId) async throws  -> [ValidationSession]
    
    /**
     * Verify that the current token is valid.
     */
    func verifyToken() throws 
    
    /**
     * Verify that the current token is valid (async).
     */
    func verifyTokenAsync() async throws 
    
    /**
     * Authenticate with username and password (blocking).
     */
    func withLogin(username: String, password: String) throws  -> Client
    
    /**
     * Authenticate with username and password (async).
     */
    func withLoginAsync(username: String, password: String) async throws  -> Client
    
    /**
     * Returns a new client connected to the specified server instance.
     *
     * Server names: "" or "saas" → production, "test", "stage", "dev", or
     * custom.
     */
    func withServer(name: String) throws  -> Client
    
    /**
     * Returns a new client with the specified authentication token.
     */
    func withToken(token: String) throws  -> Client
    
}
/**
 * Main client for interacting with EdgeFirst Studio.
 */
open class Client: ClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_edgefirst_client_fn_clone_client(self.pointer, $0) }
    }
    /**
     * Create a new client with default file token storage.
     */
public convenience init()throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_constructor_client_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_edgefirst_client_fn_free_client(pointer, $0) }
    }

    
    /**
     * Create a new client with in-memory token storage (no persistence).
     */
public static func withMemoryStorage()throws  -> Client  {
    return try  FfiConverterTypeClient_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_constructor_client_with_memory_storage($0
    )
})
}
    

    
    /**
     * Get annotation sets for a dataset.
     */
open func annotationSets(datasetId: DatasetId)throws  -> [AnnotationSet]  {
    return try  FfiConverterSequenceTypeAnnotationSet.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_annotation_sets(self.uniffiClonePointer(),
        FfiConverterTypeDatasetId_lower(datasetId),$0
    )
})
}
    
    /**
     * Get annotation sets for a dataset (async).
     */
open func annotationSetsAsync(datasetId: DatasetId)async throws  -> [AnnotationSet]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_annotation_sets_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeDatasetId_lower(datasetId)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeAnnotationSet.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get artifacts for a training session.
     */
open func artifacts(trainingSessionId: TrainingSessionId)throws  -> [Artifact]  {
    return try  FfiConverterSequenceTypeArtifact.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_artifacts(self.uniffiClonePointer(),
        FfiConverterTypeTrainingSessionId_lower(trainingSessionId),$0
    )
})
}
    
    /**
     * Get artifacts for a training session (async).
     */
open func artifactsAsync(trainingSessionId: TrainingSessionId)async throws  -> [Artifact]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_artifacts_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeTrainingSessionId_lower(trainingSessionId)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeArtifact.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get a dataset by ID.
     */
open func dataset(id: DatasetId)throws  -> Dataset  {
    return try  FfiConverterTypeDataset_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_dataset(self.uniffiClonePointer(),
        FfiConverterTypeDatasetId_lower(id),$0
    )
})
}
    
    /**
     * Get a dataset by ID (async).
     */
open func datasetAsync(id: DatasetId)async throws  -> Dataset  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_dataset_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeDatasetId_lower(id)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeDataset_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * List datasets in a project, optionally filtered by name.
     */
open func datasets(projectId: ProjectId, name: String?)throws  -> [Dataset]  {
    return try  FfiConverterSequenceTypeDataset.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_datasets(self.uniffiClonePointer(),
        FfiConverterTypeProjectId_lower(projectId),
        FfiConverterOptionString.lower(name),$0
    )
})
}
    
    /**
     * List datasets in a project (async).
     */
open func datasetsAsync(projectId: ProjectId, name: String?)async throws  -> [Dataset]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_datasets_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeProjectId_lower(projectId),FfiConverterOptionString.lower(name)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeDataset.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get an experiment by ID.
     */
open func experiment(id: ExperimentId)throws  -> Experiment  {
    return try  FfiConverterTypeExperiment_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_experiment(self.uniffiClonePointer(),
        FfiConverterTypeExperimentId_lower(id),$0
    )
})
}
    
    /**
     * Get an experiment by ID (async).
     */
open func experimentAsync(id: ExperimentId)async throws  -> Experiment  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_experiment_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeExperimentId_lower(id)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeExperiment_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * List experiments in a project, optionally filtered by name.
     */
open func experiments(projectId: ProjectId, name: String?)throws  -> [Experiment]  {
    return try  FfiConverterSequenceTypeExperiment.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_experiments(self.uniffiClonePointer(),
        FfiConverterTypeProjectId_lower(projectId),
        FfiConverterOptionString.lower(name),$0
    )
})
}
    
    /**
     * List experiments in a project (async).
     */
open func experimentsAsync(projectId: ProjectId, name: String?)async throws  -> [Experiment]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_experiments_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeProjectId_lower(projectId),FfiConverterOptionString.lower(name)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeExperiment.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get labels for a dataset.
     */
open func labels(datasetId: DatasetId)throws  -> [Label]  {
    return try  FfiConverterSequenceTypeLabel.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_labels(self.uniffiClonePointer(),
        FfiConverterTypeDatasetId_lower(datasetId),$0
    )
})
}
    
    /**
     * Get labels for a dataset (async).
     */
open func labelsAsync(datasetId: DatasetId)async throws  -> [Label]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_labels_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeDatasetId_lower(datasetId)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeLabel.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Clear authentication token and log out.
     */
open func logout()throws   {try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_logout(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Clear authentication token and log out (async).
     */
open func logoutAsync()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_logout_async(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_void,
            completeFunc: ffi_edgefirst_client_rust_future_complete_void,
            freeFunc: ffi_edgefirst_client_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get the current user's organization.
     */
open func organization()throws  -> Organization  {
    return try  FfiConverterTypeOrganization_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_organization(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the current user's organization (async).
     */
open func organizationAsync()async throws  -> Organization  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_organization_async(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOrganization_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get a project by ID.
     */
open func project(id: ProjectId)throws  -> Project  {
    return try  FfiConverterTypeProject_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_project(self.uniffiClonePointer(),
        FfiConverterTypeProjectId_lower(id),$0
    )
})
}
    
    /**
     * Get a project by ID (async).
     */
open func projectAsync(id: ProjectId)async throws  -> Project  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_project_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeProjectId_lower(id)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeProject_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * List projects, optionally filtered by name.
     */
open func projects(name: String?)throws  -> [Project]  {
    return try  FfiConverterSequenceTypeProject.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_projects(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(name),$0
    )
})
}
    
    /**
     * List projects, optionally filtered by name (async).
     */
open func projectsAsync(name: String?)async throws  -> [Project]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_projects_async(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(name)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeProject.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get a snapshot by ID.
     */
open func snapshot(id: SnapshotId)throws  -> Snapshot  {
    return try  FfiConverterTypeSnapshot_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_snapshot(self.uniffiClonePointer(),
        FfiConverterTypeSnapshotId_lower(id),$0
    )
})
}
    
    /**
     * Get a snapshot by ID (async).
     */
open func snapshotAsync(id: SnapshotId)async throws  -> Snapshot  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_snapshot_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSnapshotId_lower(id)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSnapshot_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * List snapshots, optionally filtered by name.
     */
open func snapshots(name: String?)throws  -> [Snapshot]  {
    return try  FfiConverterSequenceTypeSnapshot.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_snapshots(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(name),$0
    )
})
}
    
    /**
     * List snapshots, optionally filtered by name (async).
     */
open func snapshotsAsync(name: String?)async throws  -> [Snapshot]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_snapshots_async(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(name)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSnapshot.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get task information by ID.
     */
open func taskInfo(id: TaskId)throws  -> TaskInfo  {
    return try  FfiConverterTypeTaskInfo_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_task_info(self.uniffiClonePointer(),
        FfiConverterTypeTaskId_lower(id),$0
    )
})
}
    
    /**
     * Get task information by ID (async).
     */
open func taskInfoAsync(id: TaskId)async throws  -> TaskInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_task_info_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeTaskId_lower(id)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTaskInfo_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get a training session by ID.
     */
open func trainingSession(id: TrainingSessionId)throws  -> TrainingSession  {
    return try  FfiConverterTypeTrainingSession_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_training_session(self.uniffiClonePointer(),
        FfiConverterTypeTrainingSessionId_lower(id),$0
    )
})
}
    
    /**
     * Get a training session by ID (async).
     */
open func trainingSessionAsync(id: TrainingSessionId)async throws  -> TrainingSession  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_training_session_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeTrainingSessionId_lower(id)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTrainingSession_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * List training sessions in an experiment, optionally filtered by name.
     */
open func trainingSessions(experimentId: ExperimentId, name: String?)throws  -> [TrainingSession]  {
    return try  FfiConverterSequenceTypeTrainingSession.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_training_sessions(self.uniffiClonePointer(),
        FfiConverterTypeExperimentId_lower(experimentId),
        FfiConverterOptionString.lower(name),$0
    )
})
}
    
    /**
     * List training sessions in an experiment (async).
     */
open func trainingSessionsAsync(experimentId: ExperimentId, name: String?)async throws  -> [TrainingSession]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_training_sessions_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeExperimentId_lower(experimentId),FfiConverterOptionString.lower(name)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeTrainingSession.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get the current server URL.
     */
open func url() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_edgefirst_client_fn_method_client_url(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List validation sessions for a project.
     */
open func validationSessions(projectId: ProjectId)throws  -> [ValidationSession]  {
    return try  FfiConverterSequenceTypeValidationSession.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_validation_sessions(self.uniffiClonePointer(),
        FfiConverterTypeProjectId_lower(projectId),$0
    )
})
}
    
    /**
     * List validation sessions for a project (async).
     */
open func validationSessionsAsync(projectId: ProjectId)async throws  -> [ValidationSession]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_validation_sessions_async(
                    self.uniffiClonePointer(),
                    FfiConverterTypeProjectId_lower(projectId)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_rust_buffer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_rust_buffer,
            freeFunc: ffi_edgefirst_client_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeValidationSession.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Verify that the current token is valid.
     */
open func verifyToken()throws   {try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_verify_token(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Verify that the current token is valid (async).
     */
open func verifyTokenAsync()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_verify_token_async(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_void,
            completeFunc: ffi_edgefirst_client_rust_future_complete_void,
            freeFunc: ffi_edgefirst_client_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Authenticate with username and password (blocking).
     */
open func withLogin(username: String, password: String)throws  -> Client  {
    return try  FfiConverterTypeClient_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_with_login(self.uniffiClonePointer(),
        FfiConverterString.lower(username),
        FfiConverterString.lower(password),$0
    )
})
}
    
    /**
     * Authenticate with username and password (async).
     */
open func withLoginAsync(username: String, password: String)async throws  -> Client  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_edgefirst_client_fn_method_client_with_login_async(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(username),FfiConverterString.lower(password)
                )
            },
            pollFunc: ffi_edgefirst_client_rust_future_poll_pointer,
            completeFunc: ffi_edgefirst_client_rust_future_complete_pointer,
            freeFunc: ffi_edgefirst_client_rust_future_free_pointer,
            liftFunc: FfiConverterTypeClient_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Returns a new client connected to the specified server instance.
     *
     * Server names: "" or "saas" → production, "test", "stage", "dev", or
     * custom.
     */
open func withServer(name: String)throws  -> Client  {
    return try  FfiConverterTypeClient_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_with_server(self.uniffiClonePointer(),
        FfiConverterString.lower(name),$0
    )
})
}
    
    /**
     * Returns a new client with the specified authentication token.
     */
open func withToken(token: String)throws  -> Client  {
    return try  FfiConverterTypeClient_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_method_client_with_token(self.uniffiClonePointer(),
        FfiConverterString.lower(token),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}




/**
 * An annotation on a sample (bounding box, mask, etc.).
 */
public struct Annotation {
    /**
     * Sample this annotation belongs to.
     */
    public var sampleId: SampleId?
    /**
     * Image/sample name.
     */
    public var name: String?
    /**
     * Sequence this annotation belongs to.
     */
    public var sequenceName: String?
    /**
     * Frame number within the sequence.
     */
    public var frameNumber: UInt32?
    /**
     * Dataset split (train, val, test).
     */
    public var group: String?
    /**
     * Object tracking identifier across frames.
     */
    public var objectId: String?
    /**
     * Label/class name.
     */
    public var labelName: String?
    /**
     * Label/class index.
     */
    public var labelIndex: UInt64?
    /**
     * 2D bounding box.
     */
    public var box2d: Box2d?
    /**
     * 3D bounding box.
     */
    public var box3d: Box3d?
    /**
     * Segmentation mask.
     */
    public var mask: Mask?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Sample this annotation belongs to.
         */sampleId: SampleId?, 
        /**
         * Image/sample name.
         */name: String?, 
        /**
         * Sequence this annotation belongs to.
         */sequenceName: String?, 
        /**
         * Frame number within the sequence.
         */frameNumber: UInt32?, 
        /**
         * Dataset split (train, val, test).
         */group: String?, 
        /**
         * Object tracking identifier across frames.
         */objectId: String?, 
        /**
         * Label/class name.
         */labelName: String?, 
        /**
         * Label/class index.
         */labelIndex: UInt64?, 
        /**
         * 2D bounding box.
         */box2d: Box2d?, 
        /**
         * 3D bounding box.
         */box3d: Box3d?, 
        /**
         * Segmentation mask.
         */mask: Mask?) {
        self.sampleId = sampleId
        self.name = name
        self.sequenceName = sequenceName
        self.frameNumber = frameNumber
        self.group = group
        self.objectId = objectId
        self.labelName = labelName
        self.labelIndex = labelIndex
        self.box2d = box2d
        self.box3d = box3d
        self.mask = mask
    }
}

#if compiler(>=6)
extension Annotation: Sendable {}
#endif


extension Annotation: Equatable, Hashable {
    public static func ==(lhs: Annotation, rhs: Annotation) -> Bool {
        if lhs.sampleId != rhs.sampleId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.sequenceName != rhs.sequenceName {
            return false
        }
        if lhs.frameNumber != rhs.frameNumber {
            return false
        }
        if lhs.group != rhs.group {
            return false
        }
        if lhs.objectId != rhs.objectId {
            return false
        }
        if lhs.labelName != rhs.labelName {
            return false
        }
        if lhs.labelIndex != rhs.labelIndex {
            return false
        }
        if lhs.box2d != rhs.box2d {
            return false
        }
        if lhs.box3d != rhs.box3d {
            return false
        }
        if lhs.mask != rhs.mask {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sampleId)
        hasher.combine(name)
        hasher.combine(sequenceName)
        hasher.combine(frameNumber)
        hasher.combine(group)
        hasher.combine(objectId)
        hasher.combine(labelName)
        hasher.combine(labelIndex)
        hasher.combine(box2d)
        hasher.combine(box3d)
        hasher.combine(mask)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Annotation {
        return
            try Annotation(
                sampleId: FfiConverterOptionTypeSampleId.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                sequenceName: FfiConverterOptionString.read(from: &buf), 
                frameNumber: FfiConverterOptionUInt32.read(from: &buf), 
                group: FfiConverterOptionString.read(from: &buf), 
                objectId: FfiConverterOptionString.read(from: &buf), 
                labelName: FfiConverterOptionString.read(from: &buf), 
                labelIndex: FfiConverterOptionUInt64.read(from: &buf), 
                box2d: FfiConverterOptionTypeBox2d.read(from: &buf), 
                box3d: FfiConverterOptionTypeBox3d.read(from: &buf), 
                mask: FfiConverterOptionTypeMask.read(from: &buf)
        )
    }

    public static func write(_ value: Annotation, into buf: inout [UInt8]) {
        FfiConverterOptionTypeSampleId.write(value.sampleId, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.sequenceName, into: &buf)
        FfiConverterOptionUInt32.write(value.frameNumber, into: &buf)
        FfiConverterOptionString.write(value.group, into: &buf)
        FfiConverterOptionString.write(value.objectId, into: &buf)
        FfiConverterOptionString.write(value.labelName, into: &buf)
        FfiConverterOptionUInt64.write(value.labelIndex, into: &buf)
        FfiConverterOptionTypeBox2d.write(value.box2d, into: &buf)
        FfiConverterOptionTypeBox3d.write(value.box3d, into: &buf)
        FfiConverterOptionTypeMask.write(value.mask, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotation_lift(_ buf: RustBuffer) throws -> Annotation {
    return try FfiConverterTypeAnnotation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotation_lower(_ value: Annotation) -> RustBuffer {
    return FfiConverterTypeAnnotation.lower(value)
}


/**
 * An annotation set in a dataset.
 */
public struct AnnotationSet {
    public var id: AnnotationSetId
    public var datasetId: DatasetId
    public var name: String
    public var description: String
    public var created: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: AnnotationSetId, datasetId: DatasetId, name: String, description: String, created: String) {
        self.id = id
        self.datasetId = datasetId
        self.name = name
        self.description = description
        self.created = created
    }
}

#if compiler(>=6)
extension AnnotationSet: Sendable {}
#endif


extension AnnotationSet: Equatable, Hashable {
    public static func ==(lhs: AnnotationSet, rhs: AnnotationSet) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.datasetId != rhs.datasetId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(datasetId)
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(created)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotationSet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnnotationSet {
        return
            try AnnotationSet(
                id: FfiConverterTypeAnnotationSetId.read(from: &buf), 
                datasetId: FfiConverterTypeDatasetId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                created: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AnnotationSet, into buf: inout [UInt8]) {
        FfiConverterTypeAnnotationSetId.write(value.id, into: &buf)
        FfiConverterTypeDatasetId.write(value.datasetId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.created, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationSet_lift(_ buf: RustBuffer) throws -> AnnotationSet {
    return try FfiConverterTypeAnnotationSet.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationSet_lower(_ value: AnnotationSet) -> RustBuffer {
    return FfiConverterTypeAnnotationSet.lower(value)
}


/**
 * Unique identifier for an annotation set.
 */
public struct AnnotationSetId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension AnnotationSetId: Sendable {}
#endif


extension AnnotationSetId: Equatable, Hashable {
    public static func ==(lhs: AnnotationSetId, rhs: AnnotationSetId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotationSetId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnnotationSetId {
        return
            try AnnotationSetId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AnnotationSetId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationSetId_lift(_ buf: RustBuffer) throws -> AnnotationSetId {
    return try FfiConverterTypeAnnotationSetId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationSetId_lower(_ value: AnnotationSetId) -> RustBuffer {
    return FfiConverterTypeAnnotationSetId.lower(value)
}


/**
 * Unique identifier for an application.
 */
public struct AppId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension AppId: Sendable {}
#endif


extension AppId: Equatable, Hashable {
    public static func ==(lhs: AppId, rhs: AppId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppId {
        return
            try AppId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AppId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppId_lift(_ buf: RustBuffer) throws -> AppId {
    return try FfiConverterTypeAppId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppId_lower(_ value: AppId) -> RustBuffer {
    return FfiConverterTypeAppId.lower(value)
}


/**
 * A model artifact from a training session.
 */
public struct Artifact {
    public var name: String
    public var modelType: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, modelType: String) {
        self.name = name
        self.modelType = modelType
    }
}

#if compiler(>=6)
extension Artifact: Sendable {}
#endif


extension Artifact: Equatable, Hashable {
    public static func ==(lhs: Artifact, rhs: Artifact) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.modelType != rhs.modelType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(modelType)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeArtifact: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Artifact {
        return
            try Artifact(
                name: FfiConverterString.read(from: &buf), 
                modelType: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Artifact, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.modelType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArtifact_lift(_ buf: RustBuffer) throws -> Artifact {
    return try FfiConverterTypeArtifact.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArtifact_lower(_ value: Artifact) -> RustBuffer {
    return FfiConverterTypeArtifact.lower(value)
}


/**
 * 2D bounding box annotation.
 */
public struct Box2d {
    public var left: Float
    public var top: Float
    public var width: Float
    public var height: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(left: Float, top: Float, width: Float, height: Float) {
        self.left = left
        self.top = top
        self.width = width
        self.height = height
    }
}

#if compiler(>=6)
extension Box2d: Sendable {}
#endif


extension Box2d: Equatable, Hashable {
    public static func ==(lhs: Box2d, rhs: Box2d) -> Bool {
        if lhs.left != rhs.left {
            return false
        }
        if lhs.top != rhs.top {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(left)
        hasher.combine(top)
        hasher.combine(width)
        hasher.combine(height)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBox2d: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Box2d {
        return
            try Box2d(
                left: FfiConverterFloat.read(from: &buf), 
                top: FfiConverterFloat.read(from: &buf), 
                width: FfiConverterFloat.read(from: &buf), 
                height: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: Box2d, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.left, into: &buf)
        FfiConverterFloat.write(value.top, into: &buf)
        FfiConverterFloat.write(value.width, into: &buf)
        FfiConverterFloat.write(value.height, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBox2d_lift(_ buf: RustBuffer) throws -> Box2d {
    return try FfiConverterTypeBox2d.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBox2d_lower(_ value: Box2d) -> RustBuffer {
    return FfiConverterTypeBox2d.lower(value)
}


/**
 * 3D bounding box annotation.
 */
public struct Box3d {
    public var cx: Float
    public var cy: Float
    public var cz: Float
    public var width: Float
    public var height: Float
    public var length: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cx: Float, cy: Float, cz: Float, width: Float, height: Float, length: Float) {
        self.cx = cx
        self.cy = cy
        self.cz = cz
        self.width = width
        self.height = height
        self.length = length
    }
}

#if compiler(>=6)
extension Box3d: Sendable {}
#endif


extension Box3d: Equatable, Hashable {
    public static func ==(lhs: Box3d, rhs: Box3d) -> Bool {
        if lhs.cx != rhs.cx {
            return false
        }
        if lhs.cy != rhs.cy {
            return false
        }
        if lhs.cz != rhs.cz {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        if lhs.length != rhs.length {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cx)
        hasher.combine(cy)
        hasher.combine(cz)
        hasher.combine(width)
        hasher.combine(height)
        hasher.combine(length)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBox3d: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Box3d {
        return
            try Box3d(
                cx: FfiConverterFloat.read(from: &buf), 
                cy: FfiConverterFloat.read(from: &buf), 
                cz: FfiConverterFloat.read(from: &buf), 
                width: FfiConverterFloat.read(from: &buf), 
                height: FfiConverterFloat.read(from: &buf), 
                length: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: Box3d, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.cx, into: &buf)
        FfiConverterFloat.write(value.cy, into: &buf)
        FfiConverterFloat.write(value.cz, into: &buf)
        FfiConverterFloat.write(value.width, into: &buf)
        FfiConverterFloat.write(value.height, into: &buf)
        FfiConverterFloat.write(value.length, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBox3d_lift(_ buf: RustBuffer) throws -> Box3d {
    return try FfiConverterTypeBox3d.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBox3d_lower(_ value: Box3d) -> RustBuffer {
    return FfiConverterTypeBox3d.lower(value)
}


/**
 * A dataset in EdgeFirst Studio.
 */
public struct Dataset {
    public var id: DatasetId
    public var projectId: ProjectId
    public var name: String
    public var description: String
    public var created: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: DatasetId, projectId: ProjectId, name: String, description: String, created: String) {
        self.id = id
        self.projectId = projectId
        self.name = name
        self.description = description
        self.created = created
    }
}

#if compiler(>=6)
extension Dataset: Sendable {}
#endif


extension Dataset: Equatable, Hashable {
    public static func ==(lhs: Dataset, rhs: Dataset) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.projectId != rhs.projectId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(projectId)
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(created)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDataset: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Dataset {
        return
            try Dataset(
                id: FfiConverterTypeDatasetId.read(from: &buf), 
                projectId: FfiConverterTypeProjectId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                created: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Dataset, into buf: inout [UInt8]) {
        FfiConverterTypeDatasetId.write(value.id, into: &buf)
        FfiConverterTypeProjectId.write(value.projectId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.created, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataset_lift(_ buf: RustBuffer) throws -> Dataset {
    return try FfiConverterTypeDataset.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataset_lower(_ value: Dataset) -> RustBuffer {
    return FfiConverterTypeDataset.lower(value)
}


/**
 * Unique identifier for a dataset.
 */
public struct DatasetId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension DatasetId: Sendable {}
#endif


extension DatasetId: Equatable, Hashable {
    public static func ==(lhs: DatasetId, rhs: DatasetId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDatasetId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DatasetId {
        return
            try DatasetId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: DatasetId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatasetId_lift(_ buf: RustBuffer) throws -> DatasetId {
    return try FfiConverterTypeDatasetId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatasetId_lower(_ value: DatasetId) -> RustBuffer {
    return FfiConverterTypeDatasetId.lower(value)
}


/**
 * An experiment in EdgeFirst Studio.
 */
public struct Experiment {
    public var id: ExperimentId
    public var projectId: ProjectId
    public var name: String
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: ExperimentId, projectId: ProjectId, name: String, description: String) {
        self.id = id
        self.projectId = projectId
        self.name = name
        self.description = description
    }
}

#if compiler(>=6)
extension Experiment: Sendable {}
#endif


extension Experiment: Equatable, Hashable {
    public static func ==(lhs: Experiment, rhs: Experiment) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.projectId != rhs.projectId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(projectId)
        hasher.combine(name)
        hasher.combine(description)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExperiment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Experiment {
        return
            try Experiment(
                id: FfiConverterTypeExperimentId.read(from: &buf), 
                projectId: FfiConverterTypeProjectId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Experiment, into buf: inout [UInt8]) {
        FfiConverterTypeExperimentId.write(value.id, into: &buf)
        FfiConverterTypeProjectId.write(value.projectId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExperiment_lift(_ buf: RustBuffer) throws -> Experiment {
    return try FfiConverterTypeExperiment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExperiment_lower(_ value: Experiment) -> RustBuffer {
    return FfiConverterTypeExperiment.lower(value)
}


/**
 * Unique identifier for an experiment.
 */
public struct ExperimentId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension ExperimentId: Sendable {}
#endif


extension ExperimentId: Equatable, Hashable {
    public static func ==(lhs: ExperimentId, rhs: ExperimentId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExperimentId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExperimentId {
        return
            try ExperimentId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ExperimentId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExperimentId_lift(_ buf: RustBuffer) throws -> ExperimentId {
    return try FfiConverterTypeExperimentId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExperimentId_lower(_ value: ExperimentId) -> RustBuffer {
    return FfiConverterTypeExperimentId.lower(value)
}


/**
 * GPS location data.
 */
public struct GpsData {
    public var lat: Double
    public var lon: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lat: Double, lon: Double) {
        self.lat = lat
        self.lon = lon
    }
}

#if compiler(>=6)
extension GpsData: Sendable {}
#endif


extension GpsData: Equatable, Hashable {
    public static func ==(lhs: GpsData, rhs: GpsData) -> Bool {
        if lhs.lat != rhs.lat {
            return false
        }
        if lhs.lon != rhs.lon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lat)
        hasher.combine(lon)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGpsData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GpsData {
        return
            try GpsData(
                lat: FfiConverterDouble.read(from: &buf), 
                lon: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: GpsData, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.lat, into: &buf)
        FfiConverterDouble.write(value.lon, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGpsData_lift(_ buf: RustBuffer) throws -> GpsData {
    return try FfiConverterTypeGpsData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGpsData_lower(_ value: GpsData) -> RustBuffer {
    return FfiConverterTypeGpsData.lower(value)
}


/**
 * Unique identifier for an image.
 */
public struct ImageId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension ImageId: Sendable {}
#endif


extension ImageId: Equatable, Hashable {
    public static func ==(lhs: ImageId, rhs: ImageId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImageId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageId {
        return
            try ImageId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ImageId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImageId_lift(_ buf: RustBuffer) throws -> ImageId {
    return try FfiConverterTypeImageId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImageId_lower(_ value: ImageId) -> RustBuffer {
    return FfiConverterTypeImageId.lower(value)
}


/**
 * IMU orientation data (roll, pitch, yaw in degrees).
 */
public struct ImuData {
    public var roll: Double
    public var pitch: Double
    public var yaw: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(roll: Double, pitch: Double, yaw: Double) {
        self.roll = roll
        self.pitch = pitch
        self.yaw = yaw
    }
}

#if compiler(>=6)
extension ImuData: Sendable {}
#endif


extension ImuData: Equatable, Hashable {
    public static func ==(lhs: ImuData, rhs: ImuData) -> Bool {
        if lhs.roll != rhs.roll {
            return false
        }
        if lhs.pitch != rhs.pitch {
            return false
        }
        if lhs.yaw != rhs.yaw {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(roll)
        hasher.combine(pitch)
        hasher.combine(yaw)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImuData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImuData {
        return
            try ImuData(
                roll: FfiConverterDouble.read(from: &buf), 
                pitch: FfiConverterDouble.read(from: &buf), 
                yaw: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: ImuData, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.roll, into: &buf)
        FfiConverterDouble.write(value.pitch, into: &buf)
        FfiConverterDouble.write(value.yaw, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImuData_lift(_ buf: RustBuffer) throws -> ImuData {
    return try FfiConverterTypeImuData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImuData_lower(_ value: ImuData) -> RustBuffer {
    return FfiConverterTypeImuData.lower(value)
}


/**
 * A label for annotations.
 */
public struct Label {
    public var id: UInt64
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt64, name: String) {
        self.id = id
        self.name = name
    }
}

#if compiler(>=6)
extension Label: Sendable {}
#endif


extension Label: Equatable, Hashable {
    public static func ==(lhs: Label, rhs: Label) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLabel: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Label {
        return
            try Label(
                id: FfiConverterUInt64.read(from: &buf), 
                name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Label, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabel_lift(_ buf: RustBuffer) throws -> Label {
    return try FfiConverterTypeLabel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabel_lower(_ value: Label) -> RustBuffer {
    return FfiConverterTypeLabel.lower(value)
}


/**
 * Location and pose information for a sample.
 */
public struct Location {
    /**
     * GPS coordinates (latitude, longitude).
     */
    public var gps: GpsData?
    /**
     * IMU orientation (roll, pitch, yaw).
     */
    public var imu: ImuData?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * GPS coordinates (latitude, longitude).
         */gps: GpsData?, 
        /**
         * IMU orientation (roll, pitch, yaw).
         */imu: ImuData?) {
        self.gps = gps
        self.imu = imu
    }
}

#if compiler(>=6)
extension Location: Sendable {}
#endif


extension Location: Equatable, Hashable {
    public static func ==(lhs: Location, rhs: Location) -> Bool {
        if lhs.gps != rhs.gps {
            return false
        }
        if lhs.imu != rhs.imu {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(gps)
        hasher.combine(imu)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Location {
        return
            try Location(
                gps: FfiConverterOptionTypeGpsData.read(from: &buf), 
                imu: FfiConverterOptionTypeImuData.read(from: &buf)
        )
    }

    public static func write(_ value: Location, into buf: inout [UInt8]) {
        FfiConverterOptionTypeGpsData.write(value.gps, into: &buf)
        FfiConverterOptionTypeImuData.write(value.imu, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocation_lift(_ buf: RustBuffer) throws -> Location {
    return try FfiConverterTypeLocation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocation_lower(_ value: Location) -> RustBuffer {
    return FfiConverterTypeLocation.lower(value)
}


/**
 * Segmentation mask as a list of polygon rings.
 *
 * Each ring is a closed polygon defined by a sequence of (x, y) coordinates.
 * Multiple rings allow for complex shapes with holes.
 */
public struct Mask {
    public var polygon: [PolygonRing]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(polygon: [PolygonRing]) {
        self.polygon = polygon
    }
}

#if compiler(>=6)
extension Mask: Sendable {}
#endif


extension Mask: Equatable, Hashable {
    public static func ==(lhs: Mask, rhs: Mask) -> Bool {
        if lhs.polygon != rhs.polygon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(polygon)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMask: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mask {
        return
            try Mask(
                polygon: FfiConverterSequenceTypePolygonRing.read(from: &buf)
        )
    }

    public static func write(_ value: Mask, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePolygonRing.write(value.polygon, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMask_lift(_ buf: RustBuffer) throws -> Mask {
    return try FfiConverterTypeMask.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMask_lower(_ value: Mask) -> RustBuffer {
    return FfiConverterTypeMask.lower(value)
}


/**
 * Organization information and metadata.
 */
public struct Organization {
    public var id: OrganizationId
    public var name: String
    public var credits: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: OrganizationId, name: String, credits: Int64) {
        self.id = id
        self.name = name
        self.credits = credits
    }
}

#if compiler(>=6)
extension Organization: Sendable {}
#endif


extension Organization: Equatable, Hashable {
    public static func ==(lhs: Organization, rhs: Organization) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.credits != rhs.credits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(credits)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOrganization: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Organization {
        return
            try Organization(
                id: FfiConverterTypeOrganizationId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                credits: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Organization, into buf: inout [UInt8]) {
        FfiConverterTypeOrganizationId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterInt64.write(value.credits, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOrganization_lift(_ buf: RustBuffer) throws -> Organization {
    return try FfiConverterTypeOrganization.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOrganization_lower(_ value: Organization) -> RustBuffer {
    return FfiConverterTypeOrganization.lower(value)
}


/**
 * Unique identifier for an organization.
 */
public struct OrganizationId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension OrganizationId: Sendable {}
#endif


extension OrganizationId: Equatable, Hashable {
    public static func ==(lhs: OrganizationId, rhs: OrganizationId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOrganizationId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrganizationId {
        return
            try OrganizationId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: OrganizationId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOrganizationId_lift(_ buf: RustBuffer) throws -> OrganizationId {
    return try FfiConverterTypeOrganizationId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOrganizationId_lower(_ value: OrganizationId) -> RustBuffer {
    return FfiConverterTypeOrganizationId.lower(value)
}


/**
 * A 2D point (x, y coordinates).
 */
public struct Point2d {
    public var x: Float
    public var y: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(x: Float, y: Float) {
        self.x = x
        self.y = y
    }
}

#if compiler(>=6)
extension Point2d: Sendable {}
#endif


extension Point2d: Equatable, Hashable {
    public static func ==(lhs: Point2d, rhs: Point2d) -> Bool {
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x)
        hasher.combine(y)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePoint2d: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Point2d {
        return
            try Point2d(
                x: FfiConverterFloat.read(from: &buf), 
                y: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: Point2d, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.x, into: &buf)
        FfiConverterFloat.write(value.y, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoint2d_lift(_ buf: RustBuffer) throws -> Point2d {
    return try FfiConverterTypePoint2d.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoint2d_lower(_ value: Point2d) -> RustBuffer {
    return FfiConverterTypePoint2d.lower(value)
}


/**
 * A polygon ring as a list of 2D points.
 */
public struct PolygonRing {
    public var points: [Point2d]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(points: [Point2d]) {
        self.points = points
    }
}

#if compiler(>=6)
extension PolygonRing: Sendable {}
#endif


extension PolygonRing: Equatable, Hashable {
    public static func ==(lhs: PolygonRing, rhs: PolygonRing) -> Bool {
        if lhs.points != rhs.points {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(points)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePolygonRing: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PolygonRing {
        return
            try PolygonRing(
                points: FfiConverterSequenceTypePoint2d.read(from: &buf)
        )
    }

    public static func write(_ value: PolygonRing, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePoint2d.write(value.points, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolygonRing_lift(_ buf: RustBuffer) throws -> PolygonRing {
    return try FfiConverterTypePolygonRing.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolygonRing_lower(_ value: PolygonRing) -> RustBuffer {
    return FfiConverterTypePolygonRing.lower(value)
}


/**
 * A project in EdgeFirst Studio.
 */
public struct Project {
    public var id: ProjectId
    public var name: String
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: ProjectId, name: String, description: String) {
        self.id = id
        self.name = name
        self.description = description
    }
}

#if compiler(>=6)
extension Project: Sendable {}
#endif


extension Project: Equatable, Hashable {
    public static func ==(lhs: Project, rhs: Project) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(description)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Project {
        return
            try Project(
                id: FfiConverterTypeProjectId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Project, into buf: inout [UInt8]) {
        FfiConverterTypeProjectId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProject_lift(_ buf: RustBuffer) throws -> Project {
    return try FfiConverterTypeProject.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProject_lower(_ value: Project) -> RustBuffer {
    return FfiConverterTypeProject.lower(value)
}


/**
 * Unique identifier for a project.
 */
public struct ProjectId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension ProjectId: Sendable {}
#endif


extension ProjectId: Equatable, Hashable {
    public static func ==(lhs: ProjectId, rhs: ProjectId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProjectId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProjectId {
        return
            try ProjectId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ProjectId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectId_lift(_ buf: RustBuffer) throws -> ProjectId {
    return try FfiConverterTypeProjectId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectId_lower(_ value: ProjectId) -> RustBuffer {
    return FfiConverterTypeProjectId.lower(value)
}


/**
 * A sample in a dataset (image with metadata and annotations).
 */
public struct Sample {
    /**
     * Unique sample identifier.
     */
    public var id: SampleId?
    /**
     * Dataset split (train, val, test).
     */
    public var group: String?
    /**
     * Sequence name for video/temporal data.
     */
    public var sequenceName: String?
    /**
     * Sequence UUID.
     */
    public var sequenceUuid: String?
    /**
     * Sequence description.
     */
    public var sequenceDescription: String?
    /**
     * Frame number within the sequence.
     */
    public var frameNumber: UInt32?
    /**
     * Sample UUID.
     */
    public var uuid: String?
    /**
     * Primary image filename.
     */
    public var imageName: String?
    /**
     * URL to download the primary image.
     */
    public var imageUrl: String?
    /**
     * Image width in pixels.
     */
    public var width: UInt32?
    /**
     * Image height in pixels.
     */
    public var height: UInt32?
    /**
     * Capture date/time (ISO 8601 format).
     */
    public var date: String?
    /**
     * Data source identifier.
     */
    public var source: String?
    /**
     * Camera location and pose.
     */
    public var location: Location?
    /**
     * Image degradation type (blur, occlusion, weather, etc.).
     */
    public var degradation: String?
    /**
     * Additional sensor files (LiDAR, radar, etc.).
     */
    public var files: [SampleFile]
    /**
     * Annotations on this sample.
     */
    public var annotations: [Annotation]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique sample identifier.
         */id: SampleId?, 
        /**
         * Dataset split (train, val, test).
         */group: String?, 
        /**
         * Sequence name for video/temporal data.
         */sequenceName: String?, 
        /**
         * Sequence UUID.
         */sequenceUuid: String?, 
        /**
         * Sequence description.
         */sequenceDescription: String?, 
        /**
         * Frame number within the sequence.
         */frameNumber: UInt32?, 
        /**
         * Sample UUID.
         */uuid: String?, 
        /**
         * Primary image filename.
         */imageName: String?, 
        /**
         * URL to download the primary image.
         */imageUrl: String?, 
        /**
         * Image width in pixels.
         */width: UInt32?, 
        /**
         * Image height in pixels.
         */height: UInt32?, 
        /**
         * Capture date/time (ISO 8601 format).
         */date: String?, 
        /**
         * Data source identifier.
         */source: String?, 
        /**
         * Camera location and pose.
         */location: Location?, 
        /**
         * Image degradation type (blur, occlusion, weather, etc.).
         */degradation: String?, 
        /**
         * Additional sensor files (LiDAR, radar, etc.).
         */files: [SampleFile], 
        /**
         * Annotations on this sample.
         */annotations: [Annotation]) {
        self.id = id
        self.group = group
        self.sequenceName = sequenceName
        self.sequenceUuid = sequenceUuid
        self.sequenceDescription = sequenceDescription
        self.frameNumber = frameNumber
        self.uuid = uuid
        self.imageName = imageName
        self.imageUrl = imageUrl
        self.width = width
        self.height = height
        self.date = date
        self.source = source
        self.location = location
        self.degradation = degradation
        self.files = files
        self.annotations = annotations
    }
}

#if compiler(>=6)
extension Sample: Sendable {}
#endif


extension Sample: Equatable, Hashable {
    public static func ==(lhs: Sample, rhs: Sample) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.group != rhs.group {
            return false
        }
        if lhs.sequenceName != rhs.sequenceName {
            return false
        }
        if lhs.sequenceUuid != rhs.sequenceUuid {
            return false
        }
        if lhs.sequenceDescription != rhs.sequenceDescription {
            return false
        }
        if lhs.frameNumber != rhs.frameNumber {
            return false
        }
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.imageName != rhs.imageName {
            return false
        }
        if lhs.imageUrl != rhs.imageUrl {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        if lhs.date != rhs.date {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.location != rhs.location {
            return false
        }
        if lhs.degradation != rhs.degradation {
            return false
        }
        if lhs.files != rhs.files {
            return false
        }
        if lhs.annotations != rhs.annotations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(group)
        hasher.combine(sequenceName)
        hasher.combine(sequenceUuid)
        hasher.combine(sequenceDescription)
        hasher.combine(frameNumber)
        hasher.combine(uuid)
        hasher.combine(imageName)
        hasher.combine(imageUrl)
        hasher.combine(width)
        hasher.combine(height)
        hasher.combine(date)
        hasher.combine(source)
        hasher.combine(location)
        hasher.combine(degradation)
        hasher.combine(files)
        hasher.combine(annotations)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSample: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Sample {
        return
            try Sample(
                id: FfiConverterOptionTypeSampleId.read(from: &buf), 
                group: FfiConverterOptionString.read(from: &buf), 
                sequenceName: FfiConverterOptionString.read(from: &buf), 
                sequenceUuid: FfiConverterOptionString.read(from: &buf), 
                sequenceDescription: FfiConverterOptionString.read(from: &buf), 
                frameNumber: FfiConverterOptionUInt32.read(from: &buf), 
                uuid: FfiConverterOptionString.read(from: &buf), 
                imageName: FfiConverterOptionString.read(from: &buf), 
                imageUrl: FfiConverterOptionString.read(from: &buf), 
                width: FfiConverterOptionUInt32.read(from: &buf), 
                height: FfiConverterOptionUInt32.read(from: &buf), 
                date: FfiConverterOptionString.read(from: &buf), 
                source: FfiConverterOptionString.read(from: &buf), 
                location: FfiConverterOptionTypeLocation.read(from: &buf), 
                degradation: FfiConverterOptionString.read(from: &buf), 
                files: FfiConverterSequenceTypeSampleFile.read(from: &buf), 
                annotations: FfiConverterSequenceTypeAnnotation.read(from: &buf)
        )
    }

    public static func write(_ value: Sample, into buf: inout [UInt8]) {
        FfiConverterOptionTypeSampleId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.group, into: &buf)
        FfiConverterOptionString.write(value.sequenceName, into: &buf)
        FfiConverterOptionString.write(value.sequenceUuid, into: &buf)
        FfiConverterOptionString.write(value.sequenceDescription, into: &buf)
        FfiConverterOptionUInt32.write(value.frameNumber, into: &buf)
        FfiConverterOptionString.write(value.uuid, into: &buf)
        FfiConverterOptionString.write(value.imageName, into: &buf)
        FfiConverterOptionString.write(value.imageUrl, into: &buf)
        FfiConverterOptionUInt32.write(value.width, into: &buf)
        FfiConverterOptionUInt32.write(value.height, into: &buf)
        FfiConverterOptionString.write(value.date, into: &buf)
        FfiConverterOptionString.write(value.source, into: &buf)
        FfiConverterOptionTypeLocation.write(value.location, into: &buf)
        FfiConverterOptionString.write(value.degradation, into: &buf)
        FfiConverterSequenceTypeSampleFile.write(value.files, into: &buf)
        FfiConverterSequenceTypeAnnotation.write(value.annotations, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSample_lift(_ buf: RustBuffer) throws -> Sample {
    return try FfiConverterTypeSample.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSample_lower(_ value: Sample) -> RustBuffer {
    return FfiConverterTypeSample.lower(value)
}


/**
 * A file associated with a sample (e.g., LiDAR point cloud, radar data).
 */
public struct SampleFile {
    /**
     * File type identifier (e.g., "lidar_pcd", "radar_cube").
     */
    public var fileType: String
    /**
     * URL to download the file (present for retrieved samples).
     */
    public var url: String?
    /**
     * Local filename (used when populating samples).
     */
    public var filename: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * File type identifier (e.g., "lidar_pcd", "radar_cube").
         */fileType: String, 
        /**
         * URL to download the file (present for retrieved samples).
         */url: String?, 
        /**
         * Local filename (used when populating samples).
         */filename: String?) {
        self.fileType = fileType
        self.url = url
        self.filename = filename
    }
}

#if compiler(>=6)
extension SampleFile: Sendable {}
#endif


extension SampleFile: Equatable, Hashable {
    public static func ==(lhs: SampleFile, rhs: SampleFile) -> Bool {
        if lhs.fileType != rhs.fileType {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.filename != rhs.filename {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fileType)
        hasher.combine(url)
        hasher.combine(filename)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSampleFile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SampleFile {
        return
            try SampleFile(
                fileType: FfiConverterString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                filename: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SampleFile, into buf: inout [UInt8]) {
        FfiConverterString.write(value.fileType, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.filename, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSampleFile_lift(_ buf: RustBuffer) throws -> SampleFile {
    return try FfiConverterTypeSampleFile.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSampleFile_lower(_ value: SampleFile) -> RustBuffer {
    return FfiConverterTypeSampleFile.lower(value)
}


/**
 * Unique identifier for a sample.
 */
public struct SampleId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension SampleId: Sendable {}
#endif


extension SampleId: Equatable, Hashable {
    public static func ==(lhs: SampleId, rhs: SampleId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSampleId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SampleId {
        return
            try SampleId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SampleId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSampleId_lift(_ buf: RustBuffer) throws -> SampleId {
    return try FfiConverterTypeSampleId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSampleId_lower(_ value: SampleId) -> RustBuffer {
    return FfiConverterTypeSampleId.lower(value)
}


/**
 * Unique identifier for a sequence.
 */
public struct SequenceId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension SequenceId: Sendable {}
#endif


extension SequenceId: Equatable, Hashable {
    public static func ==(lhs: SequenceId, rhs: SequenceId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSequenceId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SequenceId {
        return
            try SequenceId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SequenceId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSequenceId_lift(_ buf: RustBuffer) throws -> SequenceId {
    return try FfiConverterTypeSequenceId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSequenceId_lower(_ value: SequenceId) -> RustBuffer {
    return FfiConverterTypeSequenceId.lower(value)
}


/**
 * A snapshot in EdgeFirst Studio.
 */
public struct Snapshot {
    public var id: SnapshotId
    public var description: String
    public var status: String
    public var path: String
    public var created: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: SnapshotId, description: String, status: String, path: String, created: String) {
        self.id = id
        self.description = description
        self.status = status
        self.path = path
        self.created = created
    }
}

#if compiler(>=6)
extension Snapshot: Sendable {}
#endif


extension Snapshot: Equatable, Hashable {
    public static func ==(lhs: Snapshot, rhs: Snapshot) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(description)
        hasher.combine(status)
        hasher.combine(path)
        hasher.combine(created)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSnapshot: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Snapshot {
        return
            try Snapshot(
                id: FfiConverterTypeSnapshotId.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                status: FfiConverterString.read(from: &buf), 
                path: FfiConverterString.read(from: &buf), 
                created: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Snapshot, into buf: inout [UInt8]) {
        FfiConverterTypeSnapshotId.write(value.id, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.status, into: &buf)
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterString.write(value.created, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSnapshot_lift(_ buf: RustBuffer) throws -> Snapshot {
    return try FfiConverterTypeSnapshot.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSnapshot_lower(_ value: Snapshot) -> RustBuffer {
    return FfiConverterTypeSnapshot.lower(value)
}


/**
 * Unique identifier for a snapshot.
 */
public struct SnapshotId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension SnapshotId: Sendable {}
#endif


extension SnapshotId: Equatable, Hashable {
    public static func ==(lhs: SnapshotId, rhs: SnapshotId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSnapshotId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SnapshotId {
        return
            try SnapshotId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SnapshotId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSnapshotId_lift(_ buf: RustBuffer) throws -> SnapshotId {
    return try FfiConverterTypeSnapshotId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSnapshotId_lower(_ value: SnapshotId) -> RustBuffer {
    return FfiConverterTypeSnapshotId.lower(value)
}


/**
 * A stage in a task's progress.
 */
public struct Stage {
    public var stage: String
    public var status: String?
    public var message: String?
    public var percentage: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(stage: String, status: String?, message: String?, percentage: UInt8) {
        self.stage = stage
        self.status = status
        self.message = message
        self.percentage = percentage
    }
}

#if compiler(>=6)
extension Stage: Sendable {}
#endif


extension Stage: Equatable, Hashable {
    public static func ==(lhs: Stage, rhs: Stage) -> Bool {
        if lhs.stage != rhs.stage {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.percentage != rhs.percentage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(stage)
        hasher.combine(status)
        hasher.combine(message)
        hasher.combine(percentage)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Stage {
        return
            try Stage(
                stage: FfiConverterString.read(from: &buf), 
                status: FfiConverterOptionString.read(from: &buf), 
                message: FfiConverterOptionString.read(from: &buf), 
                percentage: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: Stage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.stage, into: &buf)
        FfiConverterOptionString.write(value.status, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterUInt8.write(value.percentage, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStage_lift(_ buf: RustBuffer) throws -> Stage {
    return try FfiConverterTypeStage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStage_lower(_ value: Stage) -> RustBuffer {
    return FfiConverterTypeStage.lower(value)
}


/**
 * A task in EdgeFirst Studio.
 */
public struct Task {
    public var id: TaskId
    public var name: String
    public var workflow: String
    public var status: String
    public var manager: String?
    public var instance: String
    public var created: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: TaskId, name: String, workflow: String, status: String, manager: String?, instance: String, created: String) {
        self.id = id
        self.name = name
        self.workflow = workflow
        self.status = status
        self.manager = manager
        self.instance = instance
        self.created = created
    }
}

#if compiler(>=6)
extension Task: Sendable {}
#endif


extension Task: Equatable, Hashable {
    public static func ==(lhs: Task, rhs: Task) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.workflow != rhs.workflow {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.manager != rhs.manager {
            return false
        }
        if lhs.instance != rhs.instance {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(workflow)
        hasher.combine(status)
        hasher.combine(manager)
        hasher.combine(instance)
        hasher.combine(created)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTask: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Task {
        return
            try Task(
                id: FfiConverterTypeTaskId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                workflow: FfiConverterString.read(from: &buf), 
                status: FfiConverterString.read(from: &buf), 
                manager: FfiConverterOptionString.read(from: &buf), 
                instance: FfiConverterString.read(from: &buf), 
                created: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Task, into buf: inout [UInt8]) {
        FfiConverterTypeTaskId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.workflow, into: &buf)
        FfiConverterString.write(value.status, into: &buf)
        FfiConverterOptionString.write(value.manager, into: &buf)
        FfiConverterString.write(value.instance, into: &buf)
        FfiConverterString.write(value.created, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTask_lift(_ buf: RustBuffer) throws -> Task {
    return try FfiConverterTypeTask.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTask_lower(_ value: Task) -> RustBuffer {
    return FfiConverterTypeTask.lower(value)
}


/**
 * Unique identifier for a task.
 */
public struct TaskId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension TaskId: Sendable {}
#endif


extension TaskId: Equatable, Hashable {
    public static func ==(lhs: TaskId, rhs: TaskId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTaskId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TaskId {
        return
            try TaskId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TaskId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTaskId_lift(_ buf: RustBuffer) throws -> TaskId {
    return try FfiConverterTypeTaskId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTaskId_lower(_ value: TaskId) -> RustBuffer {
    return FfiConverterTypeTaskId.lower(value)
}


/**
 * Detailed task information.
 */
public struct TaskInfo {
    public var id: TaskId
    public var projectId: ProjectId?
    public var description: String
    public var workflow: String
    public var status: String?
    public var created: String
    public var completed: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: TaskId, projectId: ProjectId?, description: String, workflow: String, status: String?, created: String, completed: String) {
        self.id = id
        self.projectId = projectId
        self.description = description
        self.workflow = workflow
        self.status = status
        self.created = created
        self.completed = completed
    }
}

#if compiler(>=6)
extension TaskInfo: Sendable {}
#endif


extension TaskInfo: Equatable, Hashable {
    public static func ==(lhs: TaskInfo, rhs: TaskInfo) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.projectId != rhs.projectId {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.workflow != rhs.workflow {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        if lhs.completed != rhs.completed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(projectId)
        hasher.combine(description)
        hasher.combine(workflow)
        hasher.combine(status)
        hasher.combine(created)
        hasher.combine(completed)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTaskInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TaskInfo {
        return
            try TaskInfo(
                id: FfiConverterTypeTaskId.read(from: &buf), 
                projectId: FfiConverterOptionTypeProjectId.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                workflow: FfiConverterString.read(from: &buf), 
                status: FfiConverterOptionString.read(from: &buf), 
                created: FfiConverterString.read(from: &buf), 
                completed: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TaskInfo, into buf: inout [UInt8]) {
        FfiConverterTypeTaskId.write(value.id, into: &buf)
        FfiConverterOptionTypeProjectId.write(value.projectId, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.workflow, into: &buf)
        FfiConverterOptionString.write(value.status, into: &buf)
        FfiConverterString.write(value.created, into: &buf)
        FfiConverterString.write(value.completed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTaskInfo_lift(_ buf: RustBuffer) throws -> TaskInfo {
    return try FfiConverterTypeTaskInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTaskInfo_lower(_ value: TaskInfo) -> RustBuffer {
    return FfiConverterTypeTaskInfo.lower(value)
}


/**
 * A training session in an experiment.
 */
public struct TrainingSession {
    public var id: TrainingSessionId
    public var experimentId: ExperimentId
    public var name: String
    public var description: String
    public var model: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: TrainingSessionId, experimentId: ExperimentId, name: String, description: String, model: String) {
        self.id = id
        self.experimentId = experimentId
        self.name = name
        self.description = description
        self.model = model
    }
}

#if compiler(>=6)
extension TrainingSession: Sendable {}
#endif


extension TrainingSession: Equatable, Hashable {
    public static func ==(lhs: TrainingSession, rhs: TrainingSession) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.experimentId != rhs.experimentId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(experimentId)
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(model)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTrainingSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrainingSession {
        return
            try TrainingSession(
                id: FfiConverterTypeTrainingSessionId.read(from: &buf), 
                experimentId: FfiConverterTypeExperimentId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                model: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TrainingSession, into buf: inout [UInt8]) {
        FfiConverterTypeTrainingSessionId.write(value.id, into: &buf)
        FfiConverterTypeExperimentId.write(value.experimentId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.model, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrainingSession_lift(_ buf: RustBuffer) throws -> TrainingSession {
    return try FfiConverterTypeTrainingSession.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrainingSession_lower(_ value: TrainingSession) -> RustBuffer {
    return FfiConverterTypeTrainingSession.lower(value)
}


/**
 * Unique identifier for a training session.
 */
public struct TrainingSessionId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension TrainingSessionId: Sendable {}
#endif


extension TrainingSessionId: Equatable, Hashable {
    public static func ==(lhs: TrainingSessionId, rhs: TrainingSessionId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTrainingSessionId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrainingSessionId {
        return
            try TrainingSessionId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TrainingSessionId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrainingSessionId_lift(_ buf: RustBuffer) throws -> TrainingSessionId {
    return try FfiConverterTypeTrainingSessionId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrainingSessionId_lower(_ value: TrainingSessionId) -> RustBuffer {
    return FfiConverterTypeTrainingSessionId.lower(value)
}


/**
 * A validation session in an experiment.
 */
public struct ValidationSession {
    public var id: ValidationSessionId
    public var experimentId: ExperimentId
    public var trainingSessionId: TrainingSessionId
    public var datasetId: DatasetId
    public var annotationSetId: AnnotationSetId
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: ValidationSessionId, experimentId: ExperimentId, trainingSessionId: TrainingSessionId, datasetId: DatasetId, annotationSetId: AnnotationSetId, description: String) {
        self.id = id
        self.experimentId = experimentId
        self.trainingSessionId = trainingSessionId
        self.datasetId = datasetId
        self.annotationSetId = annotationSetId
        self.description = description
    }
}

#if compiler(>=6)
extension ValidationSession: Sendable {}
#endif


extension ValidationSession: Equatable, Hashable {
    public static func ==(lhs: ValidationSession, rhs: ValidationSession) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.experimentId != rhs.experimentId {
            return false
        }
        if lhs.trainingSessionId != rhs.trainingSessionId {
            return false
        }
        if lhs.datasetId != rhs.datasetId {
            return false
        }
        if lhs.annotationSetId != rhs.annotationSetId {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(experimentId)
        hasher.combine(trainingSessionId)
        hasher.combine(datasetId)
        hasher.combine(annotationSetId)
        hasher.combine(description)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeValidationSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidationSession {
        return
            try ValidationSession(
                id: FfiConverterTypeValidationSessionId.read(from: &buf), 
                experimentId: FfiConverterTypeExperimentId.read(from: &buf), 
                trainingSessionId: FfiConverterTypeTrainingSessionId.read(from: &buf), 
                datasetId: FfiConverterTypeDatasetId.read(from: &buf), 
                annotationSetId: FfiConverterTypeAnnotationSetId.read(from: &buf), 
                description: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ValidationSession, into buf: inout [UInt8]) {
        FfiConverterTypeValidationSessionId.write(value.id, into: &buf)
        FfiConverterTypeExperimentId.write(value.experimentId, into: &buf)
        FfiConverterTypeTrainingSessionId.write(value.trainingSessionId, into: &buf)
        FfiConverterTypeDatasetId.write(value.datasetId, into: &buf)
        FfiConverterTypeAnnotationSetId.write(value.annotationSetId, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationSession_lift(_ buf: RustBuffer) throws -> ValidationSession {
    return try FfiConverterTypeValidationSession.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationSession_lower(_ value: ValidationSession) -> RustBuffer {
    return FfiConverterTypeValidationSession.lower(value)
}


/**
 * Unique identifier for a validation session.
 */
public struct ValidationSessionId {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension ValidationSessionId: Sendable {}
#endif


extension ValidationSessionId: Equatable, Hashable {
    public static func ==(lhs: ValidationSessionId, rhs: ValidationSessionId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeValidationSessionId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidationSessionId {
        return
            try ValidationSessionId(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ValidationSessionId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationSessionId_lift(_ buf: RustBuffer) throws -> ValidationSessionId {
    return try FfiConverterTypeValidationSessionId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationSessionId_lower(_ value: ValidationSessionId) -> RustBuffer {
    return FfiConverterTypeValidationSessionId.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Annotation types supported for labeling data.
 */

public enum AnnotationType {
    
    /**
     * 2D bounding boxes for object detection in images
     */
    case box2d
    /**
     * 3D bounding boxes for object detection in 3D space
     */
    case box3d
    /**
     * Pixel-level segmentation masks
     */
    case mask
}


#if compiler(>=6)
extension AnnotationType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotationType: FfiConverterRustBuffer {
    typealias SwiftType = AnnotationType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnnotationType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .box2d
        
        case 2: return .box3d
        
        case 3: return .mask
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AnnotationType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .box2d:
            writeInt(&buf, Int32(1))
        
        
        case .box3d:
            writeInt(&buf, Int32(2))
        
        
        case .mask:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationType_lift(_ buf: RustBuffer) throws -> AnnotationType {
    return try FfiConverterTypeAnnotationType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationType_lower(_ value: AnnotationType) -> RustBuffer {
    return FfiConverterTypeAnnotationType.lower(value)
}


extension AnnotationType: Equatable, Hashable {}







/**
 * Error type for client operations.
 */
public enum ClientError: Swift.Error {

    
    
    /**
     * Authentication failed or token is invalid/expired.
     */
    case AuthenticationError(message: String
    )
    /**
     * Network or HTTP error.
     */
    case NetworkError(message: String
    )
    /**
     * Invalid parameters provided to an operation.
     */
    case InvalidParameters(message: String
    )
    /**
     * Requested resource was not found.
     */
    case NotFound(message: String
    )
    /**
     * Token storage operation failed.
     */
    case StorageError(message: String
    )
    /**
     * Internal error or unexpected condition.
     */
    case InternalError(message: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AuthenticationError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 2: return .NetworkError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidParameters(
            message: try FfiConverterString.read(from: &buf)
            )
        case 4: return .NotFound(
            message: try FfiConverterString.read(from: &buf)
            )
        case 5: return .StorageError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 6: return .InternalError(
            message: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .AuthenticationError(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .NetworkError(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .InvalidParameters(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .NotFound(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .StorageError(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .InternalError(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientError_lift(_ buf: RustBuffer) throws -> ClientError {
    return try FfiConverterTypeClientError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientError_lower(_ value: ClientError) -> RustBuffer {
    return FfiConverterTypeClientError.lower(value)
}


extension ClientError: Equatable, Hashable {}




extension ClientError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * File types supported in EdgeFirst Studio datasets.
 */

public enum FileType {
    
    /**
     * Standard image files (JPEG, PNG, etc.)
     */
    case image
    /**
     * LiDAR point cloud data files (.pcd format)
     */
    case lidarPcd
    /**
     * LiDAR depth images (.png format)
     */
    case lidarDepth
    /**
     * LiDAR reflectance images (.jpg format)
     */
    case lidarReflect
    /**
     * Radar point cloud data files (.pcd format)
     */
    case radarPcd
    /**
     * Radar cube data files (.png format)
     */
    case radarCube
}


#if compiler(>=6)
extension FileType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileType: FfiConverterRustBuffer {
    typealias SwiftType = FileType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .image
        
        case 2: return .lidarPcd
        
        case 3: return .lidarDepth
        
        case 4: return .lidarReflect
        
        case 5: return .radarPcd
        
        case 6: return .radarCube
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FileType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .image:
            writeInt(&buf, Int32(1))
        
        
        case .lidarPcd:
            writeInt(&buf, Int32(2))
        
        
        case .lidarDepth:
            writeInt(&buf, Int32(3))
        
        
        case .lidarReflect:
            writeInt(&buf, Int32(4))
        
        
        case .radarPcd:
            writeInt(&buf, Int32(5))
        
        
        case .radarCube:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileType_lift(_ buf: RustBuffer) throws -> FileType {
    return try FfiConverterTypeFileType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileType_lower(_ value: FileType) -> RustBuffer {
    return FfiConverterTypeFileType.lower(value)
}


extension FileType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Generic parameter value used in API requests and configuration.
 */

public enum Parameter {
    
    /**
     * 64-bit signed integer value.
     */
    case integer(value: Int64
    )
    /**
     * 64-bit floating-point value.
     */
    case real(value: Double
    )
    /**
     * Boolean true/false value.
     */
    case boolean(value: Bool
    )
    /**
     * UTF-8 string value.
     */
    case string(value: String
    )
    /**
     * Array of nested parameter values.
     */
    case array(values: [Parameter]
    )
    /**
     * Object/map with string keys and parameter values.
     */
    case object(entries: [String: Parameter]
    )
}


#if compiler(>=6)
extension Parameter: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParameter: FfiConverterRustBuffer {
    typealias SwiftType = Parameter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Parameter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .integer(value: try FfiConverterInt64.read(from: &buf)
        )
        
        case 2: return .real(value: try FfiConverterDouble.read(from: &buf)
        )
        
        case 3: return .boolean(value: try FfiConverterBool.read(from: &buf)
        )
        
        case 4: return .string(value: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .array(values: try FfiConverterSequenceTypeParameter.read(from: &buf)
        )
        
        case 6: return .object(entries: try FfiConverterDictionaryStringTypeParameter.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Parameter, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .integer(value):
            writeInt(&buf, Int32(1))
            FfiConverterInt64.write(value, into: &buf)
            
        
        case let .real(value):
            writeInt(&buf, Int32(2))
            FfiConverterDouble.write(value, into: &buf)
            
        
        case let .boolean(value):
            writeInt(&buf, Int32(3))
            FfiConverterBool.write(value, into: &buf)
            
        
        case let .string(value):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .array(values):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeParameter.write(values, into: &buf)
            
        
        case let .object(entries):
            writeInt(&buf, Int32(6))
            FfiConverterDictionaryStringTypeParameter.write(entries, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParameter_lift(_ buf: RustBuffer) throws -> Parameter {
    return try FfiConverterTypeParameter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParameter_lower(_ value: Parameter) -> RustBuffer {
    return FfiConverterTypeParameter.lower(value)
}


extension Parameter: Equatable, Hashable {}







/**
 * Error type for token storage operations.
 */
public enum StorageError: Swift.Error {

    
    
    /**
     * Storage is not available (e.g., cannot determine config directory).
     */
    case NotAvailable(message: String
    )
    /**
     * Failed to read token from storage.
     */
    case ReadError(message: String
    )
    /**
     * Failed to write token to storage.
     */
    case WriteError(message: String
    )
    /**
     * Failed to clear token from storage.
     */
    case ClearError(message: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageError: FfiConverterRustBuffer {
    typealias SwiftType = StorageError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NotAvailable(
            message: try FfiConverterString.read(from: &buf)
            )
        case 2: return .ReadError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 3: return .WriteError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 4: return .ClearError(
            message: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StorageError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .NotAvailable(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .ReadError(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .WriteError(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .ClearError(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageError_lift(_ buf: RustBuffer) throws -> StorageError {
    return try FfiConverterTypeStorageError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageError_lower(_ value: StorageError) -> RustBuffer {
    return FfiConverterTypeStorageError.lower(value)
}


extension StorageError: Equatable, Hashable {}




extension StorageError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}







/**
 * Trait for persistent token storage.
 *
 * Implement this interface in Kotlin/Swift to provide platform-specific
 * secure token storage (e.g., Android Keystore, iOS Keychain).
 */
public protocol TokenStorage: AnyObject, Sendable {
    
    /**
     * Store the authentication token.
     */
    func store(token: String) throws 
    
    /**
     * Load the stored authentication token.
     * Returns `None` if no token is stored.
     */
    func load() throws  -> String?
    
    /**
     * Clear the stored authentication token.
     */
    func clear() throws 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceTokenStorage {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceTokenStorage] = [UniffiVTableCallbackInterfaceTokenStorage(
        store: { (
            uniffiHandle: UInt64,
            token: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceTokenStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.store(
                     token: try FfiConverterString.lift(token)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeStorageError_lower
            )
        },
        load: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String? in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceTokenStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.load(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionString.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeStorageError_lower
            )
        },
        clear: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceTokenStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.clear(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeStorageError_lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceTokenStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface TokenStorage: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitTokenStorage() {
    uniffi_edgefirst_client_fn_init_callback_vtable_tokenstorage(UniffiCallbackInterfaceTokenStorage.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceTokenStorage {
    fileprivate static let handleMap = UniffiHandleMap<TokenStorage>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceTokenStorage : FfiConverter {
    typealias SwiftType = TokenStorage
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceTokenStorage_lift(_ handle: UInt64) throws -> TokenStorage {
    return try FfiConverterCallbackInterfaceTokenStorage.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceTokenStorage_lower(_ v: TokenStorage) -> UInt64 {
    return FfiConverterCallbackInterfaceTokenStorage.lower(v)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBox2d: FfiConverterRustBuffer {
    typealias SwiftType = Box2d?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBox2d.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBox2d.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBox3d: FfiConverterRustBuffer {
    typealias SwiftType = Box3d?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBox3d.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBox3d.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeGpsData: FfiConverterRustBuffer {
    typealias SwiftType = GpsData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeGpsData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeGpsData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeImuData: FfiConverterRustBuffer {
    typealias SwiftType = ImuData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImuData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImuData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLocation: FfiConverterRustBuffer {
    typealias SwiftType = Location?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLocation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLocation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMask: FfiConverterRustBuffer {
    typealias SwiftType = Mask?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMask.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMask.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeProjectId: FfiConverterRustBuffer {
    typealias SwiftType = ProjectId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeProjectId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeProjectId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSampleId: FfiConverterRustBuffer {
    typealias SwiftType = SampleId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSampleId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSampleId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAnnotation: FfiConverterRustBuffer {
    typealias SwiftType = [Annotation]

    public static func write(_ value: [Annotation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAnnotation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Annotation] {
        let len: Int32 = try readInt(&buf)
        var seq = [Annotation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAnnotation.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAnnotationSet: FfiConverterRustBuffer {
    typealias SwiftType = [AnnotationSet]

    public static func write(_ value: [AnnotationSet], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAnnotationSet.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AnnotationSet] {
        let len: Int32 = try readInt(&buf)
        var seq = [AnnotationSet]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAnnotationSet.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeArtifact: FfiConverterRustBuffer {
    typealias SwiftType = [Artifact]

    public static func write(_ value: [Artifact], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeArtifact.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Artifact] {
        let len: Int32 = try readInt(&buf)
        var seq = [Artifact]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeArtifact.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDataset: FfiConverterRustBuffer {
    typealias SwiftType = [Dataset]

    public static func write(_ value: [Dataset], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDataset.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Dataset] {
        let len: Int32 = try readInt(&buf)
        var seq = [Dataset]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDataset.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeExperiment: FfiConverterRustBuffer {
    typealias SwiftType = [Experiment]

    public static func write(_ value: [Experiment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeExperiment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Experiment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Experiment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeExperiment.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLabel: FfiConverterRustBuffer {
    typealias SwiftType = [Label]

    public static func write(_ value: [Label], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLabel.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Label] {
        let len: Int32 = try readInt(&buf)
        var seq = [Label]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLabel.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePoint2d: FfiConverterRustBuffer {
    typealias SwiftType = [Point2d]

    public static func write(_ value: [Point2d], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePoint2d.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Point2d] {
        let len: Int32 = try readInt(&buf)
        var seq = [Point2d]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePoint2d.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePolygonRing: FfiConverterRustBuffer {
    typealias SwiftType = [PolygonRing]

    public static func write(_ value: [PolygonRing], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePolygonRing.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PolygonRing] {
        let len: Int32 = try readInt(&buf)
        var seq = [PolygonRing]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePolygonRing.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeProject: FfiConverterRustBuffer {
    typealias SwiftType = [Project]

    public static func write(_ value: [Project], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProject.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Project] {
        let len: Int32 = try readInt(&buf)
        var seq = [Project]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeProject.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSampleFile: FfiConverterRustBuffer {
    typealias SwiftType = [SampleFile]

    public static func write(_ value: [SampleFile], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSampleFile.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SampleFile] {
        let len: Int32 = try readInt(&buf)
        var seq = [SampleFile]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSampleFile.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSnapshot: FfiConverterRustBuffer {
    typealias SwiftType = [Snapshot]

    public static func write(_ value: [Snapshot], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSnapshot.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Snapshot] {
        let len: Int32 = try readInt(&buf)
        var seq = [Snapshot]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSnapshot.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTrainingSession: FfiConverterRustBuffer {
    typealias SwiftType = [TrainingSession]

    public static func write(_ value: [TrainingSession], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrainingSession.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrainingSession] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrainingSession]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTrainingSession.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeValidationSession: FfiConverterRustBuffer {
    typealias SwiftType = [ValidationSession]

    public static func write(_ value: [ValidationSession], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeValidationSession.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ValidationSession] {
        let len: Int32 = try readInt(&buf)
        var seq = [ValidationSession]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeValidationSession.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeParameter: FfiConverterRustBuffer {
    typealias SwiftType = [Parameter]

    public static func write(_ value: [Parameter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeParameter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Parameter] {
        let len: Int32 = try readInt(&buf)
        var seq = [Parameter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeParameter.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeParameter: FfiConverterRustBuffer {
    public static func write(_ value: [String: Parameter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeParameter.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Parameter] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Parameter]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeParameter.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureEdgefirstClientInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
/**
 * Create a new client with custom token storage.
 *
 * Use this to provide platform-specific secure storage implementations.
 *
 * # Example (Kotlin)
 *
 * ```kotlin
 * class SecureStorage : TokenStorage {
 * override fun store(token: String) { /* ... */ }
 * override fun load(): String? { /* ... */ }
 * override fun clear() { /* ... */ }
 * }
 *
 * val client = createClientWithStorage(SecureStorage())
 * ```
 */
public func createClientWithStorage(storage: TokenStorage)throws  -> Client  {
    return try  FfiConverterTypeClient_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_edgefirst_client_fn_func_create_client_with_storage(
        FfiConverterCallbackInterfaceTokenStorage_lower(storage),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_edgefirst_client_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_edgefirst_client_checksum_func_create_client_with_storage() != 51357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_annotation_sets() != 52667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_annotation_sets_async() != 58035) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_artifacts() != 47017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_artifacts_async() != 51396) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_dataset() != 15504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_dataset_async() != 27919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_datasets() != 57983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_datasets_async() != 31737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_experiment() != 51030) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_experiment_async() != 14274) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_experiments() != 20493) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_experiments_async() != 40764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_labels() != 53854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_labels_async() != 3030) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_logout() != 56266) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_logout_async() != 45796) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_organization() != 54001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_organization_async() != 3202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_project() != 33098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_project_async() != 28720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_projects() != 47045) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_projects_async() != 45294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_snapshot() != 860) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_snapshot_async() != 3327) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_snapshots() != 57059) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_snapshots_async() != 36918) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_task_info() != 36680) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_task_info_async() != 13534) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_training_session() != 61626) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_training_session_async() != 20668) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_training_sessions() != 59773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_training_sessions_async() != 60165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_url() != 10365) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_validation_sessions() != 38295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_validation_sessions_async() != 27882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_verify_token() != 32558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_verify_token_async() != 9022) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_with_login() != 31228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_with_login_async() != 35885) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_with_server() != 23777) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_client_with_token() != 51792) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_constructor_client_new() != 15084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_constructor_client_with_memory_storage() != 34648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_tokenstorage_store() != 32185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_tokenstorage_load() != 6805) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_edgefirst_client_checksum_method_tokenstorage_clear() != 18446) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitTokenStorage()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureEdgefirstClientInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all